
TEST_LIB_LCD_PERRIN.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  000005de  00000672  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000005de  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000006  0080011e  0080011e  00000690  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000690  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000006c0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c8  00000000  00000000  000006fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001584  00000000  00000000  000007c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b4a  00000000  00000000  00001d48  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000009c6  00000000  00000000  00002892  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000228  00000000  00000000  00003258  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000670  00000000  00000000  00003480  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000b73  00000000  00000000  00003af0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f8  00000000  00000000  00004663  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 6b 02 	jmp	0x4d6	; 0x4d6 <__vector_24>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee ed       	ldi	r30, 0xDE	; 222
  7c:	f5 e0       	ldi	r31, 0x05	; 5
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ae 31       	cpi	r26, 0x1E	; 30
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	ae e1       	ldi	r26, 0x1E	; 30
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a4 32       	cpi	r26, 0x24	; 36
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 ff 01 	call	0x3fe	; 0x3fe <main>
  9e:	0c 94 ed 02 	jmp	0x5da	; 0x5da <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <LCD_PulseEnable>:
    /* Sets spaces (avoid error in append mode) */
    for (uint8_t i = 0; i < LCD_CHAR_NUMBER; i++)
    {
        lcd->display[i] = 0x10; 
    }
}
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	ec 01       	movw	r28, r24
  ac:	8b 81       	ldd	r24, Y+3	; 0x03
  ae:	84 60       	ori	r24, 0x04	; 4
  b0:	8b 83       	std	Y+3, r24	; 0x03
  b2:	89 83       	std	Y+1, r24	; 0x01
  b4:	62 e0       	ldi	r22, 0x02	; 2
  b6:	ce 01       	movw	r24, r28
  b8:	0e 94 4c 02 	call	0x498	; 0x498 <TWIMaster_SendMsg>
  bc:	87 e5       	ldi	r24, 0x57	; 87
  be:	92 e0       	ldi	r25, 0x02	; 2
  c0:	01 97       	sbiw	r24, 0x01	; 1
  c2:	f1 f7       	brne	.-4      	; 0xc0 <LCD_PulseEnable+0x1a>
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <LCD_PulseEnable+0x20>
  c6:	00 00       	nop
  c8:	8b 81       	ldd	r24, Y+3	; 0x03
  ca:	8b 7f       	andi	r24, 0xFB	; 251
  cc:	8b 83       	std	Y+3, r24	; 0x03
  ce:	89 83       	std	Y+1, r24	; 0x01
  d0:	62 e0       	ldi	r22, 0x02	; 2
  d2:	ce 01       	movw	r24, r28
  d4:	0e 94 4c 02 	call	0x498	; 0x498 <TWIMaster_SendMsg>
  d8:	87 e5       	ldi	r24, 0x57	; 87
  da:	92 e0       	ldi	r25, 0x02	; 2
  dc:	01 97       	sbiw	r24, 0x01	; 1
  de:	f1 f7       	brne	.-4      	; 0xdc <LCD_PulseEnable+0x36>
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <LCD_PulseEnable+0x3c>
  e2:	00 00       	nop
  e4:	df 91       	pop	r29
  e6:	cf 91       	pop	r28
  e8:	08 95       	ret

000000ea <LCD_SendInstruction>:
  ea:	1f 93       	push	r17
  ec:	cf 93       	push	r28
  ee:	df 93       	push	r29
  f0:	ec 01       	movw	r28, r24
  f2:	16 2f       	mov	r17, r22
  f4:	8b 81       	ldd	r24, Y+3	; 0x03
  f6:	96 2f       	mov	r25, r22
  f8:	90 7f       	andi	r25, 0xF0	; 240
  fa:	8c 70       	andi	r24, 0x0C	; 12
  fc:	89 2b       	or	r24, r25
  fe:	8b 83       	std	Y+3, r24	; 0x03
 100:	89 83       	std	Y+1, r24	; 0x01
 102:	62 e0       	ldi	r22, 0x02	; 2
 104:	ce 01       	movw	r24, r28
 106:	0e 94 4c 02 	call	0x498	; 0x498 <TWIMaster_SendMsg>
 10a:	8f eb       	ldi	r24, 0xBF	; 191
 10c:	9d e5       	ldi	r25, 0x5D	; 93
 10e:	01 97       	sbiw	r24, 0x01	; 1
 110:	f1 f7       	brne	.-4      	; 0x10e <LCD_SendInstruction+0x24>
 112:	00 c0       	rjmp	.+0      	; 0x114 <LCD_SendInstruction+0x2a>
 114:	00 00       	nop
 116:	ce 01       	movw	r24, r28
 118:	0e 94 53 00 	call	0xa6	; 0xa6 <LCD_PulseEnable>
 11c:	12 95       	swap	r17
 11e:	10 7f       	andi	r17, 0xF0	; 240
 120:	8b 81       	ldd	r24, Y+3	; 0x03
 122:	8f 70       	andi	r24, 0x0F	; 15
 124:	18 2b       	or	r17, r24
 126:	1b 83       	std	Y+3, r17	; 0x03
 128:	19 83       	std	Y+1, r17	; 0x01
 12a:	62 e0       	ldi	r22, 0x02	; 2
 12c:	ce 01       	movw	r24, r28
 12e:	0e 94 4c 02 	call	0x498	; 0x498 <TWIMaster_SendMsg>
 132:	8f e3       	ldi	r24, 0x3F	; 63
 134:	9f e1       	ldi	r25, 0x1F	; 31
 136:	01 97       	sbiw	r24, 0x01	; 1
 138:	f1 f7       	brne	.-4      	; 0x136 <LCD_SendInstruction+0x4c>
 13a:	00 c0       	rjmp	.+0      	; 0x13c <LCD_SendInstruction+0x52>
 13c:	00 00       	nop
 13e:	ce 01       	movw	r24, r28
 140:	0e 94 53 00 	call	0xa6	; 0xa6 <LCD_PulseEnable>
 144:	df 91       	pop	r29
 146:	cf 91       	pop	r28
 148:	1f 91       	pop	r17
 14a:	08 95       	ret

0000014c <LCD_Init>:
 14c:	1f 93       	push	r17
 14e:	cf 93       	push	r28
 150:	df 93       	push	r29
 152:	ec 01       	movw	r28, r24
 154:	10 e0       	ldi	r17, 0x00	; 0
 156:	0f c0       	rjmp	.+30     	; 0x176 <LCD_Init+0x2a>
 158:	e1 2f       	mov	r30, r17
 15a:	f0 e0       	ldi	r31, 0x00	; 0
 15c:	e0 50       	subi	r30, 0x00	; 0
 15e:	ff 4f       	sbci	r31, 0xFF	; 255
 160:	60 81       	ld	r22, Z
 162:	ce 01       	movw	r24, r28
 164:	0e 94 75 00 	call	0xea	; 0xea <LCD_SendInstruction>
 168:	8f e9       	ldi	r24, 0x9F	; 159
 16a:	9f e0       	ldi	r25, 0x0F	; 15
 16c:	01 97       	sbiw	r24, 0x01	; 1
 16e:	f1 f7       	brne	.-4      	; 0x16c <LCD_Init+0x20>
 170:	00 c0       	rjmp	.+0      	; 0x172 <LCD_Init+0x26>
 172:	00 00       	nop
 174:	1f 5f       	subi	r17, 0xFF	; 255
 176:	16 30       	cpi	r17, 0x06	; 6
 178:	78 f3       	brcs	.-34     	; 0x158 <LCD_Init+0xc>
 17a:	80 e0       	ldi	r24, 0x00	; 0
 17c:	06 c0       	rjmp	.+12     	; 0x18a <LCD_Init+0x3e>
 17e:	fe 01       	movw	r30, r28
 180:	e8 0f       	add	r30, r24
 182:	f1 1d       	adc	r31, r1
 184:	90 e2       	ldi	r25, 0x20	; 32
 186:	97 83       	std	Z+7, r25	; 0x07
 188:	8f 5f       	subi	r24, 0xFF	; 255
 18a:	80 32       	cpi	r24, 0x20	; 32
 18c:	c0 f3       	brcs	.-16     	; 0x17e <LCD_Init+0x32>
 18e:	df 91       	pop	r29
 190:	cf 91       	pop	r28
 192:	1f 91       	pop	r17
 194:	08 95       	ret

00000196 <LCD_SendChar>:
 196:	1f 93       	push	r17
 198:	cf 93       	push	r28
 19a:	df 93       	push	r29
 19c:	ec 01       	movw	r28, r24
 19e:	16 2f       	mov	r17, r22
 1a0:	8b 81       	ldd	r24, Y+3	; 0x03
 1a2:	81 60       	ori	r24, 0x01	; 1
 1a4:	96 2f       	mov	r25, r22
 1a6:	90 7f       	andi	r25, 0xF0	; 240
 1a8:	8d 70       	andi	r24, 0x0D	; 13
 1aa:	89 2b       	or	r24, r25
 1ac:	8b 83       	std	Y+3, r24	; 0x03
 1ae:	89 83       	std	Y+1, r24	; 0x01
 1b0:	62 e0       	ldi	r22, 0x02	; 2
 1b2:	ce 01       	movw	r24, r28
 1b4:	0e 94 4c 02 	call	0x498	; 0x498 <TWIMaster_SendMsg>
 1b8:	8f ea       	ldi	r24, 0xAF	; 175
 1ba:	94 e0       	ldi	r25, 0x04	; 4
 1bc:	01 97       	sbiw	r24, 0x01	; 1
 1be:	f1 f7       	brne	.-4      	; 0x1bc <LCD_SendChar+0x26>
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <LCD_SendChar+0x2c>
 1c2:	00 00       	nop
 1c4:	ce 01       	movw	r24, r28
 1c6:	0e 94 53 00 	call	0xa6	; 0xa6 <LCD_PulseEnable>
 1ca:	12 95       	swap	r17
 1cc:	10 7f       	andi	r17, 0xF0	; 240
 1ce:	8b 81       	ldd	r24, Y+3	; 0x03
 1d0:	8f 70       	andi	r24, 0x0F	; 15
 1d2:	18 2b       	or	r17, r24
 1d4:	1b 83       	std	Y+3, r17	; 0x03
 1d6:	19 83       	std	Y+1, r17	; 0x01
 1d8:	62 e0       	ldi	r22, 0x02	; 2
 1da:	ce 01       	movw	r24, r28
 1dc:	0e 94 4c 02 	call	0x498	; 0x498 <TWIMaster_SendMsg>
 1e0:	8f ea       	ldi	r24, 0xAF	; 175
 1e2:	94 e0       	ldi	r25, 0x04	; 4
 1e4:	01 97       	sbiw	r24, 0x01	; 1
 1e6:	f1 f7       	brne	.-4      	; 0x1e4 <LCD_SendChar+0x4e>
 1e8:	00 c0       	rjmp	.+0      	; 0x1ea <LCD_SendChar+0x54>
 1ea:	00 00       	nop
 1ec:	ce 01       	movw	r24, r28
 1ee:	0e 94 53 00 	call	0xa6	; 0xa6 <LCD_PulseEnable>
 1f2:	df 91       	pop	r29
 1f4:	cf 91       	pop	r28
 1f6:	1f 91       	pop	r17
 1f8:	08 95       	ret

000001fa <LCD_SetCursor>:
 1fa:	0f 93       	push	r16
 1fc:	1f 93       	push	r17
 1fe:	cf 93       	push	r28
 200:	df 93       	push	r29
 202:	62 30       	cpi	r22, 0x02	; 2
 204:	98 f4       	brcc	.+38     	; 0x22c <LCD_SetCursor+0x32>
 206:	40 31       	cpi	r20, 0x10	; 16
 208:	98 f4       	brcc	.+38     	; 0x230 <LCD_SetCursor+0x36>
 20a:	d4 2f       	mov	r29, r20
 20c:	c6 2f       	mov	r28, r22
 20e:	8c 01       	movw	r16, r24
 210:	64 2f       	mov	r22, r20
 212:	80 e4       	ldi	r24, 0x40	; 64
 214:	c8 9f       	mul	r28, r24
 216:	60 0d       	add	r22, r0
 218:	11 24       	eor	r1, r1
 21a:	60 68       	ori	r22, 0x80	; 128
 21c:	c8 01       	movw	r24, r16
 21e:	0e 94 75 00 	call	0xea	; 0xea <LCD_SendInstruction>
 222:	f8 01       	movw	r30, r16
 224:	c4 83       	std	Z+4, r28	; 0x04
 226:	d5 83       	std	Z+5, r29	; 0x05
 228:	80 e0       	ldi	r24, 0x00	; 0
 22a:	03 c0       	rjmp	.+6      	; 0x232 <LCD_SetCursor+0x38>
 22c:	81 e0       	ldi	r24, 0x01	; 1
 22e:	01 c0       	rjmp	.+2      	; 0x232 <LCD_SetCursor+0x38>
 230:	81 e0       	ldi	r24, 0x01	; 1
 232:	df 91       	pop	r29
 234:	cf 91       	pop	r28
 236:	1f 91       	pop	r17
 238:	0f 91       	pop	r16
 23a:	08 95       	ret

0000023c <LCD_ShiftLeft>:
 * and updates the cursor position accordingly.
 * 
 * @param lcd A pointer to an S_LCD_DATA structure representing the LCD state.
 */
void LCD_ShiftLeft(S_LCD_DATA *lcd)
{
 23c:	0f 93       	push	r16
 23e:	1f 93       	push	r17
 240:	cf 93       	push	r28
 242:	df 93       	push	r29
 244:	8c 01       	movw	r16, r24
    
    uint8_t tmpindex = lcd->tableIndex; 
 246:	fc 01       	movw	r30, r24
 248:	d6 81       	ldd	r29, Z+6	; 0x06
    
    // Sets cursor at start
    LCD_SendInstruction(lcd,0x01);
 24a:	61 e0       	ldi	r22, 0x01	; 1
 24c:	0e 94 75 00 	call	0xea	; 0xea <LCD_SendInstruction>
    
    LCD_SetCursor(lcd, 0, 0);
 250:	40 e0       	ldi	r20, 0x00	; 0
 252:	60 e0       	ldi	r22, 0x00	; 0
 254:	c8 01       	movw	r24, r16
 256:	0e 94 fd 00 	call	0x1fa	; 0x1fa <LCD_SetCursor>
    
    // Line 
    for (uint8_t i = 0; i < LCD_CHAR_NUMBER; i++)
 25a:	c0 e0       	ldi	r28, 0x00	; 0
 25c:	17 c0       	rjmp	.+46     	; 0x28c <LCD_ShiftLeft+0x50>
    {
        if ((tmpindex + 1) < LCD_CHAR_NUMBER)
 25e:	8d 2f       	mov	r24, r29
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	01 96       	adiw	r24, 0x01	; 1
 264:	80 97       	sbiw	r24, 0x20	; 32
 266:	14 f4       	brge	.+4      	; 0x26c <LCD_ShiftLeft+0x30>
        {
            tmpindex ++; 
 268:	df 5f       	subi	r29, 0xFF	; 255
 26a:	01 c0       	rjmp	.+2      	; 0x26e <LCD_ShiftLeft+0x32>
        }
        else
        {
            tmpindex = 0;
 26c:	d0 e0       	ldi	r29, 0x00	; 0
        }
        
        if (i == LCD_WIDTH)
 26e:	c0 31       	cpi	r28, 0x10	; 16
 270:	29 f4       	brne	.+10     	; 0x27c <LCD_ShiftLeft+0x40>
        {
            LCD_SetCursor(lcd, 1, 0);
 272:	40 e0       	ldi	r20, 0x00	; 0
 274:	61 e0       	ldi	r22, 0x01	; 1
 276:	c8 01       	movw	r24, r16
 278:	0e 94 fd 00 	call	0x1fa	; 0x1fa <LCD_SetCursor>
        }
        
        LCD_SendChar(lcd, lcd->display[tmpindex]);
 27c:	f8 01       	movw	r30, r16
 27e:	ed 0f       	add	r30, r29
 280:	f1 1d       	adc	r31, r1
 282:	67 81       	ldd	r22, Z+7	; 0x07
 284:	c8 01       	movw	r24, r16
 286:	0e 94 cb 00 	call	0x196	; 0x196 <LCD_SendChar>
    LCD_SendInstruction(lcd,0x01);
    
    LCD_SetCursor(lcd, 0, 0);
    
    // Line 
    for (uint8_t i = 0; i < LCD_CHAR_NUMBER; i++)
 28a:	cf 5f       	subi	r28, 0xFF	; 255
 28c:	c0 32       	cpi	r28, 0x20	; 32
 28e:	38 f3       	brcs	.-50     	; 0x25e <LCD_ShiftLeft+0x22>
        
        LCD_SendChar(lcd, lcd->display[tmpindex]);
    }
    
    // TO do : remove this shit code
    lcd->cursorX = LCD_WIDTH;
 290:	80 e1       	ldi	r24, 0x10	; 16
 292:	f8 01       	movw	r30, r16
 294:	85 83       	std	Z+5, r24	; 0x05
    lcd->cursorY = (LCD_LINE_NB-1);
 296:	81 e0       	ldi	r24, 0x01	; 1
 298:	84 83       	std	Z+4, r24	; 0x04
 29a:	df 91       	pop	r29
 29c:	cf 91       	pop	r28
 29e:	1f 91       	pop	r17
 2a0:	0f 91       	pop	r16
 2a2:	08 95       	ret

000002a4 <LCD_Putchar>:
 * @param  lcd Structure pointer containing LCD information
 * @param  c char to be written in LCD
 * @return uint8_t
 */
uint8_t LCD_Putchar(S_LCD_DATA *lcd, char c)
{
 2a4:	1f 93       	push	r17
 2a6:	cf 93       	push	r28
 2a8:	df 93       	push	r29
 2aa:	ec 01       	movw	r28, r24
 2ac:	16 2f       	mov	r17, r22
    uint8_t error = 0; 
    
    /* Check if append mode is enabled. If so -> put char */
    if (lcd->appendMode != 0)
 2ae:	8f a1       	ldd	r24, Y+39	; 0x27
 2b0:	88 23       	and	r24, r24
 2b2:	09 f4       	brne	.+2      	; 0x2b6 <LCD_Putchar+0x12>
 2b4:	3f c0       	rjmp	.+126    	; 0x334 <LCD_Putchar+0x90>
    {
        // if append mode is enbled, must check for column max value
        if ((lcd->cursorX) > (LCD_WIDTH - 1))
 2b6:	8d 81       	ldd	r24, Y+5	; 0x05
 2b8:	80 31       	cpi	r24, 0x10	; 16
 2ba:	50 f1       	brcs	.+84     	; 0x310 <LCD_Putchar+0x6c>
        {
            // "carriage return" 
            // @todo: change magic number for "line value"
            if (lcd->cursorY < (LCD_LINE_NB - 1))
 2bc:	6c 81       	ldd	r22, Y+4	; 0x04
 2be:	61 11       	cpse	r22, r1
 2c0:	1a c0       	rjmp	.+52     	; 0x2f6 <LCD_Putchar+0x52>
            {
                // Go to next line
                lcd->cursorY ++;
 2c2:	6f 5f       	subi	r22, 0xFF	; 255
 2c4:	6c 83       	std	Y+4, r22	; 0x04
                
                // If in first line, go to second line & first column              
                LCD_SetCursor(lcd, lcd->cursorY, 0);
 2c6:	40 e0       	ldi	r20, 0x00	; 0
 2c8:	ce 01       	movw	r24, r28
 2ca:	0e 94 fd 00 	call	0x1fa	; 0x1fa <LCD_SetCursor>
                
                // Updates Table Index
                lcd->tableIndex = (lcd->cursorY * LCD_WIDTH) + lcd->cursorX; 
 2ce:	9c 81       	ldd	r25, Y+4	; 0x04
 2d0:	8d 81       	ldd	r24, Y+5	; 0x05
 2d2:	20 e1       	ldi	r18, 0x10	; 16
 2d4:	92 9f       	mul	r25, r18
 2d6:	80 0d       	add	r24, r0
 2d8:	11 24       	eor	r1, r1
 2da:	8e 83       	std	Y+6, r24	; 0x06
                lcd->display[lcd->tableIndex] = c;
 2dc:	fe 01       	movw	r30, r28
 2de:	e8 0f       	add	r30, r24
 2e0:	f1 1d       	adc	r31, r1
 2e2:	17 83       	std	Z+7, r17	; 0x07
                
                // Send to LCD
                LCD_SendChar(lcd, c);
 2e4:	61 2f       	mov	r22, r17
 2e6:	ce 01       	movw	r24, r28
 2e8:	0e 94 cb 00 	call	0x196	; 0x196 <LCD_SendChar>
                lcd->cursorX++;
 2ec:	8d 81       	ldd	r24, Y+5	; 0x05
 2ee:	8f 5f       	subi	r24, 0xFF	; 255
 2f0:	8d 83       	std	Y+5, r24	; 0x05
 * @param  c char to be written in LCD
 * @return uint8_t
 */
uint8_t LCD_Putchar(S_LCD_DATA *lcd, char c)
{
    uint8_t error = 0; 
 2f2:	80 e0       	ldi	r24, 0x00	; 0
 2f4:	35 c0       	rjmp	.+106    	; 0x360 <LCD_Putchar+0xbc>
                lcd->cursorX++;
            }
            else
            {
                // increase index 
                lcd->tableIndex ++;
 2f6:	8e 81       	ldd	r24, Y+6	; 0x06
 2f8:	8f 5f       	subi	r24, 0xFF	; 255
                
                // Set to 0 if higher than max number of char
                lcd->tableIndex %= LCD_CHAR_NUMBER;
 2fa:	8f 71       	andi	r24, 0x1F	; 31
 2fc:	8e 83       	std	Y+6, r24	; 0x06
                
                // put char in buffer
                lcd->display[lcd->tableIndex] = c; 
 2fe:	fe 01       	movw	r30, r28
 300:	e8 0f       	add	r30, r24
 302:	f1 1d       	adc	r31, r1
 304:	17 83       	std	Z+7, r17	; 0x07
                
                // LCD_refresh
                LCD_ShiftLeft(lcd);
 306:	ce 01       	movw	r24, r28
 308:	0e 94 1e 01 	call	0x23c	; 0x23c <LCD_ShiftLeft>
 * @param  c char to be written in LCD
 * @return uint8_t
 */
uint8_t LCD_Putchar(S_LCD_DATA *lcd, char c)
{
    uint8_t error = 0; 
 30c:	80 e0       	ldi	r24, 0x00	; 0
 30e:	28 c0       	rjmp	.+80     	; 0x360 <LCD_Putchar+0xbc>
        }
        else
        {
            // max column not reached --> Sends char
            // Save char to memory
            lcd->tableIndex = (lcd->cursorY * LCD_WIDTH) + lcd->cursorX;
 310:	9c 81       	ldd	r25, Y+4	; 0x04
 312:	20 e1       	ldi	r18, 0x10	; 16
 314:	92 9f       	mul	r25, r18
 316:	80 0d       	add	r24, r0
 318:	11 24       	eor	r1, r1
 31a:	8e 83       	std	Y+6, r24	; 0x06
            lcd->display[lcd->tableIndex] = c;
 31c:	fe 01       	movw	r30, r28
 31e:	e8 0f       	add	r30, r24
 320:	f1 1d       	adc	r31, r1
 322:	67 83       	std	Z+7, r22	; 0x07
            
            // Send to LCD
            LCD_SendChar(lcd, c);
 324:	ce 01       	movw	r24, r28
 326:	0e 94 cb 00 	call	0x196	; 0x196 <LCD_SendChar>
            lcd->cursorX++;
 32a:	8d 81       	ldd	r24, Y+5	; 0x05
 32c:	8f 5f       	subi	r24, 0xFF	; 255
 32e:	8d 83       	std	Y+5, r24	; 0x05
 * @param  c char to be written in LCD
 * @return uint8_t
 */
uint8_t LCD_Putchar(S_LCD_DATA *lcd, char c)
{
    uint8_t error = 0; 
 330:	80 e0       	ldi	r24, 0x00	; 0
 332:	16 c0       	rjmp	.+44     	; 0x360 <LCD_Putchar+0xbc>
            lcd->cursorX++;
        }
    }
    else
    {
        if ((lcd->cursorX) <= LCD_WIDTH)
 334:	8d 81       	ldd	r24, Y+5	; 0x05
 336:	81 31       	cpi	r24, 0x11	; 17
 338:	90 f4       	brcc	.+36     	; 0x35e <LCD_Putchar+0xba>
        {
            // Save char to memory
            lcd->tableIndex = (lcd->cursorY * LCD_WIDTH) + lcd->cursorX;
 33a:	9c 81       	ldd	r25, Y+4	; 0x04
 33c:	20 e1       	ldi	r18, 0x10	; 16
 33e:	92 9f       	mul	r25, r18
 340:	80 0d       	add	r24, r0
 342:	11 24       	eor	r1, r1
 344:	8e 83       	std	Y+6, r24	; 0x06
            lcd->display[lcd->tableIndex] = c;
 346:	fe 01       	movw	r30, r28
 348:	e8 0f       	add	r30, r24
 34a:	f1 1d       	adc	r31, r1
 34c:	67 83       	std	Z+7, r22	; 0x07
                    
            // Send to LCD
            LCD_SendChar(lcd, c);
 34e:	ce 01       	movw	r24, r28
 350:	0e 94 cb 00 	call	0x196	; 0x196 <LCD_SendChar>
            lcd->cursorX++;
 354:	8d 81       	ldd	r24, Y+5	; 0x05
 356:	8f 5f       	subi	r24, 0xFF	; 255
 358:	8d 83       	std	Y+5, r24	; 0x05
 * @param  c char to be written in LCD
 * @return uint8_t
 */
uint8_t LCD_Putchar(S_LCD_DATA *lcd, char c)
{
    uint8_t error = 0; 
 35a:	80 e0       	ldi	r24, 0x00	; 0
 35c:	01 c0       	rjmp	.+2      	; 0x360 <LCD_Putchar+0xbc>
            LCD_SendChar(lcd, c);
            lcd->cursorX++;
        }
        else
        {
            error |= 1;
 35e:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    return error;
}
 360:	df 91       	pop	r29
 362:	cf 91       	pop	r28
 364:	1f 91       	pop	r17
 366:	08 95       	ret

00000368 <LCD_PutString>:
 * @param str A pointer to the null-terminated string to be displayed.
 *
 * @return uint8_t Returns a non-zero error code if the operation failed; otherwise 0.
 */
uint8_t LCD_PutString(S_LCD_DATA *lcd, char *str)
{
 368:	df 92       	push	r13
 36a:	ef 92       	push	r14
 36c:	ff 92       	push	r15
 36e:	0f 93       	push	r16
 370:	1f 93       	push	r17
 372:	cf 93       	push	r28
 374:	df 93       	push	r29
 376:	7c 01       	movw	r14, r24
 378:	8b 01       	movw	r16, r22
    uint8_t error = 0;
    
    uint8_t charNumber = strlen(str);
 37a:	fb 01       	movw	r30, r22
 37c:	01 90       	ld	r0, Z+
 37e:	00 20       	and	r0, r0
 380:	e9 f7       	brne	.-6      	; 0x37c <LCD_PutString+0x14>
 382:	31 97       	sbiw	r30, 0x01	; 1
 384:	e6 1b       	sub	r30, r22
 386:	f7 0b       	sbc	r31, r23
 388:	de 2e       	mov	r13, r30
    
    /* Check if append mode enabled */
    if (lcd->appendMode != 0)
 38a:	dc 01       	movw	r26, r24
 38c:	97 96       	adiw	r26, 0x27	; 39
 38e:	8c 91       	ld	r24, X
 390:	88 23       	and	r24, r24
 392:	a1 f0       	breq	.+40     	; 0x3bc <LCD_PutString+0x54>
    {
        /* String append is activated, only accept to append 31
           char, no temporary buffer if more */
        
        if (charNumber < LCD_CHAR_NUMBER)
 394:	bf e1       	ldi	r27, 0x1F	; 31
 396:	be 17       	cp	r27, r30
 398:	60 f4       	brcc	.+24     	; 0x3b2 <LCD_PutString+0x4a>
 *
 * @return uint8_t Returns a non-zero error code if the operation failed; otherwise 0.
 */
uint8_t LCD_PutString(S_LCD_DATA *lcd, char *str)
{
    uint8_t error = 0;
 39a:	c0 e0       	ldi	r28, 0x00	; 0
 39c:	27 c0       	rjmp	.+78     	; 0x3ec <LCD_PutString+0x84>
        
        if (charNumber < LCD_CHAR_NUMBER)
        {
            for (uint8_t i = 0; i < charNumber; i++)
            {
                error |= LCD_Putchar(lcd, str[i]);
 39e:	f8 01       	movw	r30, r16
 3a0:	ed 0f       	add	r30, r29
 3a2:	f1 1d       	adc	r31, r1
 3a4:	60 81       	ld	r22, Z
 3a6:	c7 01       	movw	r24, r14
 3a8:	0e 94 52 01 	call	0x2a4	; 0x2a4 <LCD_Putchar>
 3ac:	c8 2b       	or	r28, r24
        /* String append is activated, only accept to append 31
           char, no temporary buffer if more */
        
        if (charNumber < LCD_CHAR_NUMBER)
        {
            for (uint8_t i = 0; i < charNumber; i++)
 3ae:	df 5f       	subi	r29, 0xFF	; 255
 3b0:	02 c0       	rjmp	.+4      	; 0x3b6 <LCD_PutString+0x4e>
 3b2:	d0 e0       	ldi	r29, 0x00	; 0
 3b4:	c0 e0       	ldi	r28, 0x00	; 0
 3b6:	dd 15       	cp	r29, r13
 3b8:	90 f3       	brcs	.-28     	; 0x39e <LCD_PutString+0x36>
 3ba:	18 c0       	rjmp	.+48     	; 0x3ec <LCD_PutString+0x84>
    }
    else
    {
        // check if string can be placed in buffer
        // Verify if data goes over width 
        if ((lcd->cursorX + charNumber) <= LCD_WIDTH)
 3bc:	d7 01       	movw	r26, r14
 3be:	15 96       	adiw	r26, 0x05	; 5
 3c0:	8c 91       	ld	r24, X
 3c2:	90 e0       	ldi	r25, 0x00	; 0
 3c4:	8e 0f       	add	r24, r30
 3c6:	91 1d       	adc	r25, r1
 3c8:	41 97       	sbiw	r24, 0x11	; 17
 3ca:	64 f0       	brlt	.+24     	; 0x3e4 <LCD_PutString+0x7c>
            }
        }
       else
       {
            // error, width free char not sufficient
            error |= 1;
 3cc:	c1 e0       	ldi	r28, 0x01	; 1
 3ce:	0e c0       	rjmp	.+28     	; 0x3ec <LCD_PutString+0x84>
        {
            // string can be shown in display,
            // Send char by char
            for (uint8_t i = 0; i < charNumber; i++)
            {
                error |= LCD_Putchar(lcd, str[i]);
 3d0:	f8 01       	movw	r30, r16
 3d2:	ed 0f       	add	r30, r29
 3d4:	f1 1d       	adc	r31, r1
 3d6:	60 81       	ld	r22, Z
 3d8:	c7 01       	movw	r24, r14
 3da:	0e 94 52 01 	call	0x2a4	; 0x2a4 <LCD_Putchar>
 3de:	c8 2b       	or	r28, r24
        // Verify if data goes over width 
        if ((lcd->cursorX + charNumber) <= LCD_WIDTH)
        {
            // string can be shown in display,
            // Send char by char
            for (uint8_t i = 0; i < charNumber; i++)
 3e0:	df 5f       	subi	r29, 0xFF	; 255
 3e2:	02 c0       	rjmp	.+4      	; 0x3e8 <LCD_PutString+0x80>
 3e4:	d0 e0       	ldi	r29, 0x00	; 0
 3e6:	c0 e0       	ldi	r28, 0x00	; 0
 3e8:	dd 15       	cp	r29, r13
 3ea:	90 f3       	brcs	.-28     	; 0x3d0 <LCD_PutString+0x68>
            error |= 1;
       }
    }
    
   return error;
}
 3ec:	8c 2f       	mov	r24, r28
 3ee:	df 91       	pop	r29
 3f0:	cf 91       	pop	r28
 3f2:	1f 91       	pop	r17
 3f4:	0f 91       	pop	r16
 3f6:	ff 90       	pop	r15
 3f8:	ef 90       	pop	r14
 3fa:	df 90       	pop	r13
 3fc:	08 95       	ret

000003fe <main>:
#include "AVR_LCD_1602_I2C.h"
#include <stdio.h>


int main(void)
{
 3fe:	cf 93       	push	r28
 400:	df 93       	push	r29
 402:	cd b7       	in	r28, 0x3d	; 61
 404:	de b7       	in	r29, 0x3e	; 62
 406:	a9 97       	sbiw	r28, 0x29	; 41
 408:	0f b6       	in	r0, 0x3f	; 63
 40a:	f8 94       	cli
 40c:	de bf       	out	0x3e, r29	; 62
 40e:	0f be       	out	0x3f, r0	; 63
 410:	cd bf       	out	0x3d, r28	; 61
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 412:	2f ef       	ldi	r18, 0xFF	; 255
 414:	81 ee       	ldi	r24, 0xE1	; 225
 416:	94 e0       	ldi	r25, 0x04	; 4
 418:	21 50       	subi	r18, 0x01	; 1
 41a:	80 40       	sbci	r24, 0x00	; 0
 41c:	90 40       	sbci	r25, 0x00	; 0
 41e:	e1 f7       	brne	.-8      	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
 420:	00 c0       	rjmp	.+0      	; 0x422 <__EEPROM_REGION_LENGTH__+0x22>
 422:	00 00       	nop
    /* Start-up delay */
    _delay_ms(100);
    
    /* Structure for LCD Data */
    S_LCD_DATA lcd = {  .i2c.S_MsgSplit.SlaveAdress = 0x25,
 424:	8e 01       	movw	r16, r28
 426:	0f 5f       	subi	r16, 0xFF	; 255
 428:	1f 4f       	sbci	r17, 0xFF	; 255
 42a:	89 e2       	ldi	r24, 0x29	; 41
 42c:	f8 01       	movw	r30, r16
 42e:	11 92       	st	Z+, r1
 430:	8a 95       	dec	r24
 432:	e9 f7       	brne	.-6      	; 0x42e <__EEPROM_REGION_LENGTH__+0x2e>
 434:	89 81       	ldd	r24, Y+1	; 0x01
 436:	81 70       	andi	r24, 0x01	; 1
 438:	8a 64       	ori	r24, 0x4A	; 74
 43a:	89 83       	std	Y+1, r24	; 0x01
 43c:	8c 81       	ldd	r24, Y+4	; 0x04
 43e:	88 60       	ori	r24, 0x08	; 8
 440:	8c 83       	std	Y+4, r24	; 0x04
 442:	81 e0       	ldi	r24, 0x01	; 1
 444:	88 a7       	std	Y+40, r24	; 0x28
                        .tableIndex = 0x00,
                        .appendMode = 0x01,
                        .error = 0x00,      
                        .pcfdata.reg.backlight = 0x01};

    sei();
 446:	78 94       	sei

    /* Initialize I2C + LCD */
    TWIMaster_Init();
 448:	0e 94 39 02 	call	0x472	; 0x472 <TWIMaster_Init>
	LCD_Init(&lcd);
 44c:	c8 01       	movw	r24, r16
 44e:	0e 94 a6 00 	call	0x14c	; 0x14c <LCD_Init>
	
	
	/* Testing LCD screen */
	LCD_PutString(&lcd,"QUOI ? ");
 452:	66 e0       	ldi	r22, 0x06	; 6
 454:	71 e0       	ldi	r23, 0x01	; 1
 456:	c8 01       	movw	r24, r16
 458:	0e 94 b4 01 	call	0x368	; 0x368 <LCD_PutString>
 	LCD_SetCursor(&lcd, 1, 0);
 45c:	40 e0       	ldi	r20, 0x00	; 0
 45e:	61 e0       	ldi	r22, 0x01	; 1
 460:	c8 01       	movw	r24, r16
 462:	0e 94 fd 00 	call	0x1fa	; 0x1fa <LCD_SetCursor>
	LCD_PutString(&lcd, "QUOICOUBEEEEHHH");
 466:	6e e0       	ldi	r22, 0x0E	; 14
 468:	71 e0       	ldi	r23, 0x01	; 1
 46a:	c8 01       	movw	r24, r16
 46c:	0e 94 b4 01 	call	0x368	; 0x368 <LCD_PutString>
 470:	ff cf       	rjmp	.-2      	; 0x470 <__EEPROM_REGION_LENGTH__+0x70>

00000472 <TWIMaster_Init>:
}

U_TWI_Status TWI_GetTransmitStatus (void)
{
	return TWI_StatusTxRx;
}
 472:	e9 eb       	ldi	r30, 0xB9	; 185
 474:	f0 e0       	ldi	r31, 0x00	; 0
 476:	80 81       	ld	r24, Z
 478:	8c 7f       	andi	r24, 0xFC	; 252
 47a:	80 83       	st	Z, r24
 47c:	80 81       	ld	r24, Z
 47e:	80 83       	st	Z, r24
 480:	88 e1       	ldi	r24, 0x18	; 24
 482:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7f80b8>
 486:	8f ef       	ldi	r24, 0xFF	; 255
 488:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
 48c:	ec eb       	ldi	r30, 0xBC	; 188
 48e:	f0 e0       	ldi	r31, 0x00	; 0
 490:	10 82       	st	Z, r1
 492:	84 e0       	ldi	r24, 0x04	; 4
 494:	80 83       	st	Z, r24
 496:	08 95       	ret

00000498 <TWIMaster_SendMsg>:
 498:	fc 01       	movw	r30, r24
 49a:	60 93 20 01 	sts	0x0120, r22	; 0x800120 <TWI_MsgSize>
 49e:	80 81       	ld	r24, Z
 4a0:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <TWI_BufferTxRx>
 4a4:	80 81       	ld	r24, Z
 4a6:	80 ff       	sbrs	r24, 0
 4a8:	0d c0       	rjmp	.+26     	; 0x4c4 <TWIMaster_SendMsg+0x2c>
 4aa:	0f c0       	rjmp	.+30     	; 0x4ca <TWIMaster_SendMsg+0x32>
 4ac:	29 2f       	mov	r18, r25
 4ae:	30 e0       	ldi	r19, 0x00	; 0
 4b0:	df 01       	movw	r26, r30
 4b2:	a2 0f       	add	r26, r18
 4b4:	b3 1f       	adc	r27, r19
 4b6:	8c 91       	ld	r24, X
 4b8:	d9 01       	movw	r26, r18
 4ba:	af 5d       	subi	r26, 0xDF	; 223
 4bc:	be 4f       	sbci	r27, 0xFE	; 254
 4be:	8c 93       	st	X, r24
 4c0:	9f 5f       	subi	r25, 0xFF	; 255
 4c2:	01 c0       	rjmp	.+2      	; 0x4c6 <TWIMaster_SendMsg+0x2e>
 4c4:	91 e0       	ldi	r25, 0x01	; 1
 4c6:	96 17       	cp	r25, r22
 4c8:	88 f3       	brcs	.-30     	; 0x4ac <TWIMaster_SendMsg+0x14>
 4ca:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <TWI_StatusTxRx>
 4ce:	85 ea       	ldi	r24, 0xA5	; 165
 4d0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 4d4:	08 95       	ret

000004d6 <__vector_24>:
*	l'interruption envoie les données qui s'y trouvent. 
*
*/

ISR(TWI_vect)
{
 4d6:	1f 92       	push	r1
 4d8:	0f 92       	push	r0
 4da:	0f b6       	in	r0, 0x3f	; 63
 4dc:	0f 92       	push	r0
 4de:	11 24       	eor	r1, r1
 4e0:	2f 93       	push	r18
 4e2:	3f 93       	push	r19
 4e4:	8f 93       	push	r24
 4e6:	9f 93       	push	r25
 4e8:	ef 93       	push	r30
 4ea:	ff 93       	push	r31
	static uint8_t MsgPtr = 0;		// Pointeur de message (Static = 
								// valeur reste après l'interruption)
								
	switch (TWSR)
 4ec:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
 4f0:	88 32       	cpi	r24, 0x28	; 40
 4f2:	a1 f0       	breq	.+40     	; 0x51c <__vector_24+0x46>
 4f4:	40 f4       	brcc	.+16     	; 0x506 <__vector_24+0x30>
 4f6:	80 31       	cpi	r24, 0x10	; 16
 4f8:	79 f0       	breq	.+30     	; 0x518 <__vector_24+0x42>
 4fa:	88 31       	cpi	r24, 0x18	; 24
 4fc:	79 f0       	breq	.+30     	; 0x51c <__vector_24+0x46>
 4fe:	88 30       	cpi	r24, 0x08	; 8
 500:	09 f0       	breq	.+2      	; 0x504 <__vector_24+0x2e>
 502:	58 c0       	rjmp	.+176    	; 0x5b4 <__vector_24+0xde>
 504:	09 c0       	rjmp	.+18     	; 0x518 <__vector_24+0x42>
 506:	80 35       	cpi	r24, 0x50	; 80
 508:	31 f1       	breq	.+76     	; 0x556 <__vector_24+0x80>
 50a:	88 35       	cpi	r24, 0x58	; 88
 50c:	09 f4       	brne	.+2      	; 0x510 <__vector_24+0x3a>
 50e:	41 c0       	rjmp	.+130    	; 0x592 <__vector_24+0xbc>
 510:	80 34       	cpi	r24, 0x40	; 64
 512:	09 f0       	breq	.+2      	; 0x516 <__vector_24+0x40>
 514:	4f c0       	rjmp	.+158    	; 0x5b4 <__vector_24+0xde>
 516:	2b c0       	rjmp	.+86     	; 0x56e <__vector_24+0x98>
	{
		case TWI_START:							// Si une condition de start ou de Repeated start
		case TWI_REP_START:						// a été envoyé, remet le pointeur à "0" et charge 
		MsgPtr = 0;								// l'adresse 
 518:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <__data_end>
		case TWI_WR_ADR_ACK:					// Cette condition s'applique également si l'écriture
		case TWI_WR_DATA_ACK:					// a été notifiée par un ACK 
			if (MsgPtr < TWI_MsgSize)			// Si la totalité n'a pas été envoyée
 51c:	e0 91 1e 01 	lds	r30, 0x011E	; 0x80011e <__data_end>
 520:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <TWI_MsgSize>
 524:	e8 17       	cp	r30, r24
 526:	70 f4       	brcc	.+28     	; 0x544 <__vector_24+0x6e>
			{
				TWDR = TWI_BufferTxRx[MsgPtr++];
 528:	81 e0       	ldi	r24, 0x01	; 1
 52a:	8e 0f       	add	r24, r30
 52c:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <__data_end>
 530:	f0 e0       	ldi	r31, 0x00	; 0
 532:	ef 5d       	subi	r30, 0xDF	; 223
 534:	fe 4f       	sbci	r31, 0xFE	; 254
 536:	80 81       	ld	r24, Z
 538:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
				TWCR = (1<<TWEN)|                          // Active le périphérique TWI
 53c:	85 e8       	ldi	r24, 0x85	; 133
 53e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 542:	40 c0       	rjmp	.+128    	; 0x5c4 <__vector_24+0xee>
				(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				(0<<TWWC);                                 //
			}
			else								// Si la totalité du message a été envoyée								
			{
				TWI_StatusTxRx.S_StatusBit.TransmitOk = 0x01;	// Règle le bit de status (TX OK) 
 544:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <TWI_StatusTxRx>
 548:	81 60       	ori	r24, 0x01	; 1
 54a:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <TWI_StatusTxRx>
				TWCR = (1<<TWEN)|									// Active le périphérique TWI
 54e:	84 e9       	ldi	r24, 0x94	; 148
 550:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 554:	37 c0       	rjmp	.+110    	; 0x5c4 <__vector_24+0xee>
				(0<<TWWC);											//
			}
		break;
		
    case TWI_RD_DATA_ACK:					// Si un byte a été reçu et ACK envoyé
		TWI_BufferTxRx[MsgPtr++] = TWDR;
 556:	e0 91 1e 01 	lds	r30, 0x011E	; 0x80011e <__data_end>
 55a:	81 e0       	ldi	r24, 0x01	; 1
 55c:	8e 0f       	add	r24, r30
 55e:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <__data_end>
 562:	f0 e0       	ldi	r31, 0x00	; 0
 564:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
 568:	ef 5d       	subi	r30, 0xDF	; 223
 56a:	fe 4f       	sbci	r31, 0xFE	; 254
 56c:	80 83       	st	Z, r24
		
    case TWI_RD_ADR_ACK:					// L'adresse et la notification ont été reçu par le SLAVE
    if (MsgPtr < (TWI_MsgSize-1) )          // Vérifie si il s'agit du dernier byte à lire 
 56e:	20 91 1e 01 	lds	r18, 0x011E	; 0x80011e <__data_end>
 572:	30 e0       	ldi	r19, 0x00	; 0
 574:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <TWI_MsgSize>
 578:	90 e0       	ldi	r25, 0x00	; 0
 57a:	01 97       	sbiw	r24, 0x01	; 1
 57c:	28 17       	cp	r18, r24
 57e:	39 07       	cpc	r19, r25
 580:	24 f4       	brge	.+8      	; 0x58a <__vector_24+0xb4>
    {
		// Si ce n'est pas le cas,
	    TWCR = (1<<TWEN)|                   // Met à Jour le Registre TWCR 
 582:	85 ec       	ldi	r24, 0xC5	; 197
 584:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 588:	1d c0       	rjmp	.+58     	; 0x5c4 <__vector_24+0xee>
	    (0<<TWWC);                          
    }
	else									     
    {
		// Si tout les bytes ont étés lus
	    TWCR = (1<<TWEN)|                          // Met à jour le TWCR
 58a:	85 e8       	ldi	r24, 0x85	; 133
 58c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 590:	19 c0       	rjmp	.+50     	; 0x5c4 <__vector_24+0xee>
	    (0<<TWWC);                                 //
    }
    break;
	
    case TWI_RD_DATA_NACK:								// Le dernier byte à été reçu (nack envoyé)
		TWI_BufferTxRx[MsgPtr] = TWDR;					// Sauve les données
 592:	e0 91 1e 01 	lds	r30, 0x011E	; 0x80011e <__data_end>
 596:	f0 e0       	ldi	r31, 0x00	; 0
 598:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
 59c:	ef 5d       	subi	r30, 0xDF	; 223
 59e:	fe 4f       	sbci	r31, 0xFE	; 254
 5a0:	80 83       	st	Z, r24
		TWI_StatusTxRx.S_StatusBit.TransmitOk = 0x01;	// Flag de communication terminée correctement
 5a2:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <TWI_StatusTxRx>
 5a6:	81 60       	ori	r24, 0x01	; 1
 5a8:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <TWI_StatusTxRx>
		 
		TWCR = (1<<TWEN)|                          // Met à jour le registre de configuration TWI
 5ac:	84 e9       	ldi	r24, 0x94	; 148
 5ae:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
		(0<<TWIE)|(1<<TWINT)|                      // Désactive les interruptions et clear le Flag 
		(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Envoie la condition de stop 
		(0<<TWWC);                                 //
    break;
 5b2:	08 c0       	rjmp	.+16     	; 0x5c4 <__vector_24+0xee>
    case TWI_RD_ADR_NACK:		// Envoi de l'adresse + R, mais slave réponds avec NACK
    case TWI_WR_DATA_NACK:		// Envoi d'un byte, mais slave réponds avec NACK 
    case TWI_ERROR_BUS:			// Error sur le bus (Condition illegale (ex: Start-Stop)
    default:
		//TWI_state = TWSR;				// Sauve le registre de status et
		TWI_StatusTxRx.S_StatusBit.TransmitOk = 0x00;	// Efface le FLag de validation
 5b4:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <TWI_StatusTxRx>
 5b8:	8e 7f       	andi	r24, 0xFE	; 254
 5ba:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <TWI_StatusTxRx>
    
		// Reset TWI Interface
		TWCR = (1<<TWEN)|					// Mise à jour du registre de CONF
 5be:	84 e0       	ldi	r24, 0x04	; 4
 5c0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
		(0<<TWIE)|(0<<TWINT)|				// Désactive les interruptions
		(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|	// Stoppe la communication en cours
		(0<<TWWC);							//		
	}
}
 5c4:	ff 91       	pop	r31
 5c6:	ef 91       	pop	r30
 5c8:	9f 91       	pop	r25
 5ca:	8f 91       	pop	r24
 5cc:	3f 91       	pop	r19
 5ce:	2f 91       	pop	r18
 5d0:	0f 90       	pop	r0
 5d2:	0f be       	out	0x3f, r0	; 63
 5d4:	0f 90       	pop	r0
 5d6:	1f 90       	pop	r1
 5d8:	18 95       	reti

000005da <_exit>:
 5da:	f8 94       	cli

000005dc <__stop_program>:
 5dc:	ff cf       	rjmp	.-2      	; 0x5dc <__stop_program>
