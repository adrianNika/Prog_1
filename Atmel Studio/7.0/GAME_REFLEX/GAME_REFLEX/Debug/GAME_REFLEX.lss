
GAME_REFLEX.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009c  00800100  000017e8  0000187c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000017e8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000dc  0080019c  0080019c  00001918  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001918  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001974  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001e8  00000000  00000000  000019b0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002391  00000000  00000000  00001b98  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f3b  00000000  00000000  00003f29  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001598  00000000  00000000  00004e64  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005b8  00000000  00000000  000063fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000b59  00000000  00000000  000069b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000015b9  00000000  00000000  0000750d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001c8  00000000  00000000  00008ac6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 ba 02 	jmp	0x574	; 0x574 <__vector_6>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 18 03 	jmp	0x630	; 0x630 <__vector_10>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 fd 02 	jmp	0x5fa	; 0x5fa <__vector_13>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 a7 00 	jmp	0x14e	; 0x14e <__vector_18>
      4c:	0c 94 6a 00 	jmp	0xd4	; 0xd4 <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 5f 06 	jmp	0xcbe	; 0xcbe <__vector_24>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 ee       	ldi	r30, 0xE8	; 232
      7c:	f7 e1       	ldi	r31, 0x17	; 23
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ac 39       	cpi	r26, 0x9C	; 156
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	22 e0       	ldi	r18, 0x02	; 2
      8c:	ac e9       	ldi	r26, 0x9C	; 156
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a8 37       	cpi	r26, 0x78	; 120
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 9c 03 	call	0x738	; 0x738 <main>
      9e:	0c 94 f2 0b 	jmp	0x17e4	; 0x17e4 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <UART_Init>:
	TX_Head = 0;
	TX_Tail = 0; 
	
	// returning ErrorUart (no-cost operation) 
	return ErrorUart;
}
      a6:	82 e0       	ldi	r24, 0x02	; 2
      a8:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
      ac:	88 eb       	ldi	r24, 0xB8	; 184
      ae:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
      b2:	86 e0       	ldi	r24, 0x06	; 6
      b4:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
      b8:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
      bc:	8f ec       	ldi	r24, 0xCF	; 207
      be:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
      c2:	10 92 a0 01 	sts	0x01A0, r1	; 0x8001a0 <RX_Tail>
      c6:	10 92 a1 01 	sts	0x01A1, r1	; 0x8001a1 <RX_Head>
      ca:	10 92 9e 01 	sts	0x019E, r1	; 0x80019e <TX_Tail>
      ce:	10 92 9f 01 	sts	0x019F, r1	; 0x80019f <TX_Head>
      d2:	08 95       	ret

000000d4 <__vector_19>:
      d4:	1f 92       	push	r1
      d6:	0f 92       	push	r0
      d8:	0f b6       	in	r0, 0x3f	; 63
      da:	0f 92       	push	r0
      dc:	11 24       	eor	r1, r1
      de:	2f 93       	push	r18
      e0:	8f 93       	push	r24
      e2:	9f 93       	push	r25
      e4:	ef 93       	push	r30
      e6:	ff 93       	push	r31
      e8:	90 91 9e 01 	lds	r25, 0x019E	; 0x80019e <TX_Tail>
      ec:	80 91 9f 01 	lds	r24, 0x019F	; 0x80019f <TX_Head>
      f0:	98 17       	cp	r25, r24
      f2:	d9 f0       	breq	.+54     	; 0x12a <__vector_19+0x56>
      f4:	90 91 9e 01 	lds	r25, 0x019E	; 0x80019e <TX_Tail>
      f8:	9f 5f       	subi	r25, 0xFF	; 255
      fa:	89 2f       	mov	r24, r25
      fc:	86 95       	lsr	r24
      fe:	2b ee       	ldi	r18, 0xEB	; 235
     100:	82 9f       	mul	r24, r18
     102:	81 2d       	mov	r24, r1
     104:	11 24       	eor	r1, r1
     106:	82 95       	swap	r24
     108:	86 95       	lsr	r24
     10a:	87 70       	andi	r24, 0x07	; 7
     10c:	26 e4       	ldi	r18, 0x46	; 70
     10e:	82 9f       	mul	r24, r18
     110:	90 19       	sub	r25, r0
     112:	11 24       	eor	r1, r1
     114:	90 93 9e 01 	sts	0x019E, r25	; 0x80019e <TX_Tail>
     118:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <TX_Tail>
     11c:	f0 e0       	ldi	r31, 0x00	; 0
     11e:	ee 55       	subi	r30, 0x5E	; 94
     120:	fe 4f       	sbci	r31, 0xFE	; 254
     122:	80 81       	ld	r24, Z
     124:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     128:	05 c0       	rjmp	.+10     	; 0x134 <__vector_19+0x60>
     12a:	e1 ec       	ldi	r30, 0xC1	; 193
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	80 81       	ld	r24, Z
     130:	8f 7d       	andi	r24, 0xDF	; 223
     132:	80 83       	st	Z, r24
     134:	ff 91       	pop	r31
     136:	ef 91       	pop	r30
     138:	9f 91       	pop	r25
     13a:	8f 91       	pop	r24
     13c:	2f 91       	pop	r18
     13e:	0f 90       	pop	r0
     140:	0f be       	out	0x3f, r0	; 63
     142:	0f 90       	pop	r0
     144:	1f 90       	pop	r1
     146:	18 95       	reti

00000148 <Uart_SetELOEndCharDetected>:
 * @param  value Value of flag to be set
 * @return void
 */
void Uart_SetELOEndCharDetected(uint8_t value)
{
	EloEndCharDetected = value;
     148:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <__data_end>
     14c:	08 95       	ret

0000014e <__vector_18>:
 * When interrupt occures, the new data has to be stored in circular buffer.
 * Head pointer increases, only if buffer is not full.
 *
*/
ISR(USART_RX_vect)
{
     14e:	1f 92       	push	r1
     150:	0f 92       	push	r0
     152:	0f b6       	in	r0, 0x3f	; 63
     154:	0f 92       	push	r0
     156:	11 24       	eor	r1, r1
     158:	2f 93       	push	r18
     15a:	3f 93       	push	r19
     15c:	4f 93       	push	r20
     15e:	5f 93       	push	r21
     160:	6f 93       	push	r22
     162:	7f 93       	push	r23
     164:	8f 93       	push	r24
     166:	9f 93       	push	r25
     168:	af 93       	push	r26
     16a:	bf 93       	push	r27
     16c:	ef 93       	push	r30
     16e:	ff 93       	push	r31
	char data;			// Temporary (to empty UDR)
	uint8_t tmpRXHead;	// Temporary (for computations) 
	
	data = UDR_REG;		// empty UDR in temporary variable 
     170:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
						// this permits to receive another data (avoid loss)
	
	tmpRXHead = RX_Head + 1;			// Increase position of tmp head 
     174:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <RX_Head>
     178:	9f 5f       	subi	r25, 0xFF	; 255
	tmpRXHead %= UART_RX_BUFFER_SIZE;	// cycling buffer position if max reached
     17a:	89 2f       	mov	r24, r25
     17c:	86 95       	lsr	r24
     17e:	eb ee       	ldi	r30, 0xEB	; 235
     180:	8e 9f       	mul	r24, r30
     182:	e1 2d       	mov	r30, r1
     184:	11 24       	eor	r1, r1
     186:	e2 95       	swap	r30
     188:	e6 95       	lsr	r30
     18a:	e7 70       	andi	r30, 0x07	; 7
     18c:	86 e4       	ldi	r24, 0x46	; 70
     18e:	e8 9f       	mul	r30, r24
     190:	90 19       	sub	r25, r0
     192:	11 24       	eor	r1, r1
	
	// Is RX_Buffer full ? 
	if (tmpRXHead == RX_Tail)
     194:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <RX_Tail>
     198:	98 13       	cpse	r25, r24
     19a:	06 c0       	rjmp	.+12     	; 0x1a8 <__vector_18+0x5a>
	{
		// --> ERROR : RX Buffer is full 
		ErrorUart |= UART_ERROR_RX_BUFFER_FULL; // Buffer is full, handle exeption ! 
     19c:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <ErrorUart>
     1a0:	82 60       	ori	r24, 0x02	; 2
     1a2:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <ErrorUart>
     1a6:	0c c0       	rjmp	.+24     	; 0x1c0 <__vector_18+0x72>
	}
	else
	{
		RX_Head = tmpRXHead ;			// Save new pointer position
     1a8:	90 93 a1 01 	sts	0x01A1, r25	; 0x8001a1 <RX_Head>
		RX_Buffer[tmpRXHead] = data;	// Save data in buffer
     1ac:	e9 2f       	mov	r30, r25
     1ae:	f0 e0       	ldi	r31, 0x00	; 0
     1b0:	e8 51       	subi	r30, 0x18	; 24
     1b2:	fe 4f       	sbci	r31, 0xFE	; 254
     1b4:	20 83       	st	Z, r18
		
		// ELO Protocole handling
		if (data == '*')
     1b6:	2a 32       	cpi	r18, 0x2A	; 42
     1b8:	19 f4       	brne	.+6      	; 0x1c0 <__vector_18+0x72>
		{
			Uart_SetELOEndCharDetected(0x01);
     1ba:	81 e0       	ldi	r24, 0x01	; 1
     1bc:	0e 94 a4 00 	call	0x148	; 0x148 <Uart_SetELOEndCharDetected>
		}
	}
}
     1c0:	ff 91       	pop	r31
     1c2:	ef 91       	pop	r30
     1c4:	bf 91       	pop	r27
     1c6:	af 91       	pop	r26
     1c8:	9f 91       	pop	r25
     1ca:	8f 91       	pop	r24
     1cc:	7f 91       	pop	r23
     1ce:	6f 91       	pop	r22
     1d0:	5f 91       	pop	r21
     1d2:	4f 91       	pop	r20
     1d4:	3f 91       	pop	r19
     1d6:	2f 91       	pop	r18
     1d8:	0f 90       	pop	r0
     1da:	0f be       	out	0x3f, r0	; 63
     1dc:	0f 90       	pop	r0
     1de:	1f 90       	pop	r1
     1e0:	18 95       	reti

000001e2 <LCD_Strobe_E>:
}


/*fait une pulse "E" pour l'evois des instruction ou caractére*/
void LCD_Strobe_E(void)
{
     1e2:	cf 93       	push	r28
     1e4:	df 93       	push	r29
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1e6:	8f ec       	ldi	r24, 0xCF	; 207
     1e8:	97 e0       	ldi	r25, 0x07	; 7
     1ea:	01 97       	sbiw	r24, 0x01	; 1
     1ec:	f1 f7       	brne	.-4      	; 0x1ea <LCD_Strobe_E+0x8>
     1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <LCD_Strobe_E+0xe>
     1f0:	00 00       	nop
	_delay_us(500);
	lcdCtrl.PcfRegs.enableBit = 1;
     1f2:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <lcdCtrl>
     1f6:	84 60       	ori	r24, 0x04	; 4
     1f8:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <lcdCtrl>
	i2cLcd.S_MsgSplit.Message[0] = lcdCtrl.pcfByte;
     1fc:	c1 e7       	ldi	r28, 0x71	; 113
     1fe:	d2 e0       	ldi	r29, 0x02	; 2
     200:	89 83       	std	Y+1, r24	; 0x01
	TWIMaster_SendMsg(i2cLcd.MsgBuffer, 2);
     202:	62 e0       	ldi	r22, 0x02	; 2
     204:	ce 01       	movw	r24, r28
     206:	0e 94 40 06 	call	0xc80	; 0xc80 <TWIMaster_SendMsg>
     20a:	8f ec       	ldi	r24, 0xCF	; 207
     20c:	97 e0       	ldi	r25, 0x07	; 7
     20e:	01 97       	sbiw	r24, 0x01	; 1
     210:	f1 f7       	brne	.-4      	; 0x20e <LCD_Strobe_E+0x2c>
     212:	00 c0       	rjmp	.+0      	; 0x214 <LCD_Strobe_E+0x32>
     214:	00 00       	nop
	_delay_us(500);
	lcdCtrl.PcfRegs.enableBit = 0;
     216:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <lcdCtrl>
     21a:	8b 7f       	andi	r24, 0xFB	; 251
     21c:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <lcdCtrl>
	i2cLcd.S_MsgSplit.Message[0] = lcdCtrl.pcfByte;
     220:	89 83       	std	Y+1, r24	; 0x01
	TWIMaster_SendMsg(i2cLcd.MsgBuffer, 2);
     222:	62 e0       	ldi	r22, 0x02	; 2
     224:	ce 01       	movw	r24, r28
     226:	0e 94 40 06 	call	0xc80	; 0xc80 <TWIMaster_SendMsg>
     22a:	8f ec       	ldi	r24, 0xCF	; 207
     22c:	97 e0       	ldi	r25, 0x07	; 7
     22e:	01 97       	sbiw	r24, 0x01	; 1
     230:	f1 f7       	brne	.-4      	; 0x22e <LCD_Strobe_E+0x4c>
     232:	00 c0       	rjmp	.+0      	; 0x234 <LCD_Strobe_E+0x52>
     234:	00 00       	nop
	_delay_us(500);
}
     236:	df 91       	pop	r29
     238:	cf 91       	pop	r28
     23a:	08 95       	ret

0000023c <LCD_Init>:
		initialiser chaque data sur du 4 bits pour le lCD
		strobe de Enable pour chaque instruction (datasheet)
		
*/
uint8_t LCD_Init(uint8_t initLCD, uint8_t slaveAdrr)
{
     23c:	0f 93       	push	r16
     23e:	1f 93       	push	r17
     240:	cf 93       	push	r28
     242:	df 93       	push	r29
     244:	cd b7       	in	r28, 0x3d	; 61
     246:	de b7       	in	r29, 0x3e	; 62
     248:	2e 97       	sbiw	r28, 0x0e	; 14
     24a:	0f b6       	in	r0, 0x3f	; 63
     24c:	f8 94       	cli
     24e:	de bf       	out	0x3e, r29	; 62
     250:	0f be       	out	0x3f, r0	; 63
     252:	cd bf       	out	0x3d, r28	; 61
	actual_Val_Char = 0;
     254:	10 92 53 02 	sts	0x0253, r1	; 0x800253 <actual_Val_Char>
	ctrlInit.byte = initLCD;
     258:	80 93 6d 02 	sts	0x026D, r24	; 0x80026d <ctrlInit>
	
	if (ctrlInit.byte > 15)
     25c:	80 31       	cpi	r24, 0x10	; 16
     25e:	28 f0       	brcs	.+10     	; 0x26a <LCD_Init+0x2e>
	{
		ErrorLCD |= ERROR_INIT;
     260:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <ErrorLCD>
     264:	81 60       	ori	r24, 0x01	; 1
     266:	80 93 54 02 	sts	0x0254, r24	; 0x800254 <ErrorLCD>
	}
	
	if (ErrorLCD == 0)
     26a:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <ErrorLCD>
     26e:	81 11       	cpse	r24, r1
     270:	80 c0       	rjmp	.+256    	; 0x372 <LCD_Init+0x136>
	{
		lcdCtrl.PcfRegs.rsBit = 0;
     272:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <lcdCtrl>
     276:	8e 7f       	andi	r24, 0xFE	; 254
     278:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <lcdCtrl>
		
		/*valeur union action init*/
		/*pour le nombre de ligne*/
		ctrlLine.S_Set_Line.nbLine = ctrlInit.S_LCDInit.nb_line;
     27c:	90 91 6d 02 	lds	r25, 0x026D	; 0x80026d <ctrlInit>
     280:	93 fb       	bst	r25, 3
     282:	22 27       	eor	r18, r18
     284:	20 f9       	bld	r18, 0
     286:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <ctrlLine>
     28a:	20 fb       	bst	r18, 0
     28c:	83 f9       	bld	r24, 3
     28e:	80 93 70 02 	sts	0x0270, r24	; 0x800270 <ctrlLine>
		
		/*pour le curseur*/
		ctrlCursor.S_setCursor.blikingSet = ctrlInit.S_LCDInit.bliking_Set;
     292:	91 fb       	bst	r25, 1
     294:	22 27       	eor	r18, r18
     296:	20 f9       	bld	r18, 0
     298:	80 91 6c 02 	lds	r24, 0x026C	; 0x80026c <ctrlCursor>
     29c:	20 fb       	bst	r18, 0
     29e:	80 f9       	bld	r24, 0
		ctrlCursor.S_setCursor.cursorSet = ctrlInit.S_LCDInit.cursor_set;
     2a0:	92 fb       	bst	r25, 2
     2a2:	22 27       	eor	r18, r18
     2a4:	20 f9       	bld	r18, 0
     2a6:	20 fb       	bst	r18, 0
     2a8:	81 f9       	bld	r24, 1
		ctrlCursor.S_setCursor.displayOn = 1;
		ctrlCursor.S_setCursor.isone = 1;
     2aa:	84 60       	ori	r24, 0x04	; 4
     2ac:	88 60       	ori	r24, 0x08	; 8
     2ae:	80 93 6c 02 	sts	0x026C, r24	; 0x80026c <ctrlCursor>
		
		ctrlDisplay.S_setDiplay.isZero1 = 0;
     2b2:	80 91 6e 02 	lds	r24, 0x026E	; 0x80026e <ctrlDisplay>
		ctrlDisplay.S_setDiplay.cursorIncDec = ctrlInit.S_LCDInit.incDec_cursor;
     2b6:	8e 7f       	andi	r24, 0xFE	; 254
     2b8:	90 fb       	bst	r25, 0
     2ba:	81 f9       	bld	r24, 1
		ctrlDisplay.S_setDiplay.isone = 1;
		ctrlDisplay.S_setDiplay.isZero2 = 0;
     2bc:	84 60       	ori	r24, 0x04	; 4
     2be:	87 7f       	andi	r24, 0xF7	; 247
     2c0:	80 93 6e 02 	sts	0x026E, r24	; 0x80026e <ctrlDisplay>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     2c4:	2f ef       	ldi	r18, 0xFF	; 255
     2c6:	81 ee       	ldi	r24, 0xE1	; 225
     2c8:	94 e0       	ldi	r25, 0x04	; 4
     2ca:	21 50       	subi	r18, 0x01	; 1
     2cc:	80 40       	sbci	r24, 0x00	; 0
     2ce:	90 40       	sbci	r25, 0x00	; 0
     2d0:	e1 f7       	brne	.-8      	; 0x2ca <LCD_Init+0x8e>
     2d2:	00 c0       	rjmp	.+0      	; 0x2d4 <LCD_Init+0x98>
     2d4:	00 00       	nop
		
		/* Start-up delay */
		_delay_ms(100);
		
		/* Initialize with adress */
		i2cLcd.S_MsgSplit.SlaveAdress = slaveAdrr;
     2d6:	e1 e7       	ldi	r30, 0x71	; 113
     2d8:	f2 e0       	ldi	r31, 0x02	; 2
     2da:	66 0f       	add	r22, r22
     2dc:	80 81       	ld	r24, Z
     2de:	81 70       	andi	r24, 0x01	; 1
		i2cLcd.S_MsgSplit.ReadWriteBit = TWI_WRITE;
     2e0:	68 2b       	or	r22, r24
     2e2:	6e 7f       	andi	r22, 0xFE	; 254
     2e4:	60 83       	st	Z, r22
		
		/* Initialize with LCD data*/
		lcdCtrl.PcfRegs.rsBit = 0;
     2e6:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <lcdCtrl>
		lcdCtrl.PcfRegs.rwBit = 0;
		lcdCtrl.PcfRegs.enableBit = 0;
		lcdCtrl.PcfRegs.backlight = 1;
     2ea:	88 7f       	andi	r24, 0xF8	; 248
     2ec:	88 60       	ori	r24, 0x08	; 8
		lcdCtrl.PcfRegs.data = 0;
     2ee:	8f 70       	andi	r24, 0x0F	; 15
     2f0:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <lcdCtrl>
		
		/*all data init*/
		uint8_t buffer_Data[] = {	0x03,
     2f4:	83 e0       	ldi	r24, 0x03	; 3
     2f6:	89 83       	std	Y+1, r24	; 0x01
     2f8:	8a 83       	std	Y+2, r24	; 0x02
     2fa:	8b 83       	std	Y+3, r24	; 0x03
     2fc:	82 e0       	ldi	r24, 0x02	; 2
     2fe:	8c 83       	std	Y+4, r24	; 0x04
     300:	8d 83       	std	Y+5, r24	; 0x05
									0x03,
									0x03,
									0x02,
									0x02,
									ctrlLine.byte,
     302:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <ctrlLine>
		lcdCtrl.PcfRegs.enableBit = 0;
		lcdCtrl.PcfRegs.backlight = 1;
		lcdCtrl.PcfRegs.data = 0;
		
		/*all data init*/
		uint8_t buffer_Data[] = {	0x03,
     306:	8e 83       	std	Y+6, r24	; 0x06
     308:	1f 82       	std	Y+7, r1	; 0x07
     30a:	88 e0       	ldi	r24, 0x08	; 8
     30c:	88 87       	std	Y+8, r24	; 0x08
     30e:	19 86       	std	Y+9, r1	; 0x09
     310:	81 e0       	ldi	r24, 0x01	; 1
     312:	8a 87       	std	Y+10, r24	; 0x0a
     314:	1b 86       	std	Y+11, r1	; 0x0b
									0x00,
									0x08,
									0x00,
									0x01,
									0x00,
									ctrlDisplay.byte,
     316:	80 91 6e 02 	lds	r24, 0x026E	; 0x80026e <ctrlDisplay>
		lcdCtrl.PcfRegs.enableBit = 0;
		lcdCtrl.PcfRegs.backlight = 1;
		lcdCtrl.PcfRegs.data = 0;
		
		/*all data init*/
		uint8_t buffer_Data[] = {	0x03,
     31a:	8c 87       	std	Y+12, r24	; 0x0c
     31c:	1d 86       	std	Y+13, r1	; 0x0d
									0x00,
									0x01,
									0x00,
									ctrlDisplay.byte,
									0x00,
									ctrlCursor.byte};
     31e:	80 91 6c 02 	lds	r24, 0x026C	; 0x80026c <ctrlCursor>
		lcdCtrl.PcfRegs.enableBit = 0;
		lcdCtrl.PcfRegs.backlight = 1;
		lcdCtrl.PcfRegs.data = 0;
		
		/*all data init*/
		uint8_t buffer_Data[] = {	0x03,
     322:	8e 87       	std	Y+14, r24	; 0x0e
									ctrlDisplay.byte,
									0x00,
									ctrlCursor.byte};
		
		/*send all data init*/
		for (int i = 0; i < 14; i++)
     324:	00 e0       	ldi	r16, 0x00	; 0
     326:	10 e0       	ldi	r17, 0x00	; 0
     328:	21 c0       	rjmp	.+66     	; 0x36c <LCD_Init+0x130>
		{	
			lcdCtrl.PcfRegs.data = buffer_Data[i];
     32a:	e1 e0       	ldi	r30, 0x01	; 1
     32c:	f0 e0       	ldi	r31, 0x00	; 0
     32e:	ec 0f       	add	r30, r28
     330:	fd 1f       	adc	r31, r29
     332:	e0 0f       	add	r30, r16
     334:	f1 1f       	adc	r31, r17
     336:	80 81       	ld	r24, Z
     338:	98 2f       	mov	r25, r24
     33a:	92 95       	swap	r25
     33c:	90 7f       	andi	r25, 0xF0	; 240
     33e:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <lcdCtrl>
     342:	8f 70       	andi	r24, 0x0F	; 15
     344:	89 2b       	or	r24, r25
     346:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <lcdCtrl>
			i2cLcd.S_MsgSplit.Message[0] = lcdCtrl.pcfByte;
     34a:	80 93 72 02 	sts	0x0272, r24	; 0x800272 <i2cLcd+0x1>
			TWIMaster_SendMsg(i2cLcd.MsgBuffer, 2);
     34e:	62 e0       	ldi	r22, 0x02	; 2
     350:	81 e7       	ldi	r24, 0x71	; 113
     352:	92 e0       	ldi	r25, 0x02	; 2
     354:	0e 94 40 06 	call	0xc80	; 0xc80 <TWIMaster_SendMsg>
     358:	8f e3       	ldi	r24, 0x3F	; 63
     35a:	9c e9       	ldi	r25, 0x9C	; 156
     35c:	01 97       	sbiw	r24, 0x01	; 1
     35e:	f1 f7       	brne	.-4      	; 0x35c <LCD_Init+0x120>
     360:	00 c0       	rjmp	.+0      	; 0x362 <LCD_Init+0x126>
     362:	00 00       	nop
			_delay_ms(10);
			LCD_Strobe_E();
     364:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_Strobe_E>
									ctrlDisplay.byte,
									0x00,
									ctrlCursor.byte};
		
		/*send all data init*/
		for (int i = 0; i < 14; i++)
     368:	0f 5f       	subi	r16, 0xFF	; 255
     36a:	1f 4f       	sbci	r17, 0xFF	; 255
     36c:	0e 30       	cpi	r16, 0x0E	; 14
     36e:	11 05       	cpc	r17, r1
     370:	e4 f2       	brlt	.-72     	; 0x32a <LCD_Init+0xee>
			LCD_Strobe_E();
		}
	}
	
	return ErrorLCD;
}
     372:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <ErrorLCD>
     376:	2e 96       	adiw	r28, 0x0e	; 14
     378:	0f b6       	in	r0, 0x3f	; 63
     37a:	f8 94       	cli
     37c:	de bf       	out	0x3e, r29	; 62
     37e:	0f be       	out	0x3f, r0	; 63
     380:	cd bf       	out	0x3d, r28	; 61
     382:	df 91       	pop	r29
     384:	cf 91       	pop	r28
     386:	1f 91       	pop	r17
     388:	0f 91       	pop	r16
     38a:	08 95       	ret

0000038c <LCD_SendInstruction>:
		le rs bit a 1 ou 0 pour les instruction et les caractéres.
		
		evois des 4 bits et strobe de E pour chaque envois (demande datasheet)
*/
void LCD_SendInstruction(char value, uint8_t type)
{
     38c:	0f 93       	push	r16
     38e:	1f 93       	push	r17
     390:	cf 93       	push	r28
	uint8_t high_Value = 0;
	uint8_t low_Value = 0;
	
	/*isoler nible de point fort*/
	high_Value = (uint8_t)value >> 4;
     392:	98 2f       	mov	r25, r24
     394:	92 95       	swap	r25
     396:	9f 70       	andi	r25, 0x0F	; 15
	
	/*avoir que le nible de poids faible ex: 0x41 - 0x40 = 0x01*/
	low_Value = (uint8_t)value - (high_Value << 4);
     398:	c8 2f       	mov	r28, r24
     39a:	20 e1       	ldi	r18, 0x10	; 16
     39c:	92 9f       	mul	r25, r18
     39e:	c0 19       	sub	r28, r0
     3a0:	11 24       	eor	r1, r1
	
	/*type pour pour instruction ou caractere*/
	if (type == 1)
     3a2:	61 30       	cpi	r22, 0x01	; 1
     3a4:	31 f4       	brne	.+12     	; 0x3b2 <LCD_SendInstruction+0x26>
	{
		lcdCtrl.PcfRegs.rsBit = 1;
     3a6:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <lcdCtrl>
     3aa:	81 60       	ori	r24, 0x01	; 1
     3ac:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <lcdCtrl>
     3b0:	05 c0       	rjmp	.+10     	; 0x3bc <LCD_SendInstruction+0x30>
	}
	else
	{
		lcdCtrl.PcfRegs.rsBit = 0;
     3b2:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <lcdCtrl>
     3b6:	8e 7f       	andi	r24, 0xFE	; 254
     3b8:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <lcdCtrl>
	
	
	/*traitement pour l'initialisation en 4 bits*/
	
	/*traitement nible fort*/
	lcdCtrl.PcfRegs.data = high_Value;
     3bc:	92 95       	swap	r25
     3be:	90 7f       	andi	r25, 0xF0	; 240
     3c0:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <lcdCtrl>
     3c4:	8f 70       	andi	r24, 0x0F	; 15
     3c6:	89 2b       	or	r24, r25
     3c8:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <lcdCtrl>
	i2cLcd.S_MsgSplit.Message[0] = lcdCtrl.pcfByte;
     3cc:	01 e7       	ldi	r16, 0x71	; 113
     3ce:	12 e0       	ldi	r17, 0x02	; 2
     3d0:	f8 01       	movw	r30, r16
     3d2:	81 83       	std	Z+1, r24	; 0x01
	TWIMaster_SendMsg(i2cLcd.MsgBuffer, 2);
     3d4:	62 e0       	ldi	r22, 0x02	; 2
     3d6:	c8 01       	movw	r24, r16
     3d8:	0e 94 40 06 	call	0xc80	; 0xc80 <TWIMaster_SendMsg>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3dc:	87 ec       	ldi	r24, 0xC7	; 199
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	01 97       	sbiw	r24, 0x01	; 1
     3e2:	f1 f7       	brne	.-4      	; 0x3e0 <LCD_SendInstruction+0x54>
     3e4:	00 c0       	rjmp	.+0      	; 0x3e6 <LCD_SendInstruction+0x5a>
     3e6:	00 00       	nop
	_delay_us(50);
	LCD_Strobe_E();
     3e8:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_Strobe_E>
	
	/*traitement nible fiable*/
	lcdCtrl.PcfRegs.data = low_Value;
     3ec:	8c 2f       	mov	r24, r28
     3ee:	82 95       	swap	r24
     3f0:	80 7f       	andi	r24, 0xF0	; 240
     3f2:	90 91 6f 02 	lds	r25, 0x026F	; 0x80026f <lcdCtrl>
     3f6:	9f 70       	andi	r25, 0x0F	; 15
     3f8:	89 2b       	or	r24, r25
     3fa:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <lcdCtrl>
	i2cLcd.S_MsgSplit.Message[0] = lcdCtrl.pcfByte;
     3fe:	f8 01       	movw	r30, r16
     400:	81 83       	std	Z+1, r24	; 0x01
	TWIMaster_SendMsg(i2cLcd.MsgBuffer, 2);
     402:	62 e0       	ldi	r22, 0x02	; 2
     404:	c8 01       	movw	r24, r16
     406:	0e 94 40 06 	call	0xc80	; 0xc80 <TWIMaster_SendMsg>
     40a:	87 ec       	ldi	r24, 0xC7	; 199
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	01 97       	sbiw	r24, 0x01	; 1
     410:	f1 f7       	brne	.-4      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
     412:	00 c0       	rjmp	.+0      	; 0x414 <__EEPROM_REGION_LENGTH__+0x14>
     414:	00 00       	nop
	_delay_us(50);
	LCD_Strobe_E();
     416:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_Strobe_E>
}
     41a:	cf 91       	pop	r28
     41c:	1f 91       	pop	r17
     41e:	0f 91       	pop	r16
     420:	08 95       	ret

00000422 <LCD_setCursor>:
	/*
		si valeur de line trop grand --> error
		si valeur trop grand Max caractere --> error
	*/
	
	if (lin > 1)
     422:	82 30       	cpi	r24, 0x02	; 2
     424:	28 f0       	brcs	.+10     	; 0x430 <LCD_setCursor+0xe>
	{
		ErrorLCD |= ERROR_CURSOR;
     426:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <ErrorLCD>
     42a:	92 60       	ori	r25, 0x02	; 2
     42c:	90 93 54 02 	sts	0x0254, r25	; 0x800254 <ErrorLCD>
	}
	if (col < 0 || lin > 15)
     430:	80 31       	cpi	r24, 0x10	; 16
     432:	28 f0       	brcs	.+10     	; 0x43e <LCD_setCursor+0x1c>
	{
		ErrorLCD |= ERROR_CURSOR;
     434:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <ErrorLCD>
     438:	92 60       	ori	r25, 0x02	; 2
     43a:	90 93 54 02 	sts	0x0254, r25	; 0x800254 <ErrorLCD>
	}
	
	if (ErrorLCD == 0)
     43e:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <ErrorLCD>
     442:	91 11       	cpse	r25, r1
     444:	17 c0       	rjmp	.+46     	; 0x474 <LCD_setCursor+0x52>
	{
		valueCol = col;
     446:	60 93 2f 02 	sts	0x022F, r22	; 0x80022f <valueCol>
		valueLin = lin;
		actual_Val_Line = lin;
	
		/*pour afficher sur la ligne du bas l'adresse commence par 0x4X*/
		if (valueLin == 1)
     44a:	81 30       	cpi	r24, 0x01	; 1
     44c:	31 f4       	brne	.+12     	; 0x45a <LCD_setCursor+0x38>
		{
			/*0x04 pour utilisation de l'union et l'envois en 4bits*/
			valueLin = 0x40;
     44e:	80 e4       	ldi	r24, 0x40	; 64
     450:	80 93 2e 02 	sts	0x022E, r24	; 0x80022e <valueLin>
			actual_Val_Char = col;
     454:	60 93 53 02 	sts	0x0253, r22	; 0x800253 <actual_Val_Char>
     458:	04 c0       	rjmp	.+8      	; 0x462 <LCD_setCursor+0x40>
		}
		else
		{
			valueLin = 0x00;
     45a:	10 92 2e 02 	sts	0x022E, r1	; 0x80022e <valueLin>
			actual_Val_Char = col;
     45e:	60 93 53 02 	sts	0x0253, r22	; 0x800253 <actual_Val_Char>
					2		-  -  -   1   0   0   x   x   x   x 
		1 = l'adresse a voir dans la datasheet obligatoir
		2 = la partie de l'adresse corespondant a la ligne 2 de l'écran
		le DB7  a 1 et important pour set le cursor a l'endroit voulu 
		+ 0x08 (-> DB7) pour avoir l'aresse complet*/
		LCD_SendInstruction((0x80 + valueLin) + valueCol, 0);
     462:	90 91 2e 02 	lds	r25, 0x022E	; 0x80022e <valueLin>
     466:	80 91 2f 02 	lds	r24, 0x022F	; 0x80022f <valueCol>
     46a:	89 0f       	add	r24, r25
     46c:	60 e0       	ldi	r22, 0x00	; 0
     46e:	80 58       	subi	r24, 0x80	; 128
     470:	0e 94 c6 01 	call	0x38c	; 0x38c <LCD_SendInstruction>
	}
	
	return ErrorLCD;
}
     474:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <ErrorLCD>
     478:	08 95       	ret

0000047a <LCD_PutChar>:
			
			après la boucle un delais de 500ms pour la fluiditer et la 
			lisibilité du text avec le décallage.	  	
*/
uint8_t LCD_PutChar(char C)
{		
     47a:	cf 93       	push	r28
	{
		buffer_SIZE = 16;
	} 
	else
	{
		buffer_SIZE = 32;
     47c:	90 e2       	ldi	r25, 0x20	; 32
     47e:	90 93 55 02 	sts	0x0255, r25	; 0x800255 <buffer_SIZE>
	}
	
	
	/*error max lengh char*/
	if (actual_Val_Char > buffer_SIZE && SCROLL_MODE == 0)
     482:	90 91 53 02 	lds	r25, 0x0253	; 0x800253 <actual_Val_Char>
     486:	91 32       	cpi	r25, 0x21	; 33
     488:	28 f0       	brcs	.+10     	; 0x494 <LCD_PutChar+0x1a>
	{
		ErrorLCD |= ERROR_HIGH_LENGH_CHAR;
     48a:	20 91 54 02 	lds	r18, 0x0254	; 0x800254 <ErrorLCD>
     48e:	24 60       	ori	r18, 0x04	; 4
     490:	20 93 54 02 	sts	0x0254, r18	; 0x800254 <ErrorLCD>
	}
	
	if (ErrorLCD == 0)
     494:	20 91 54 02 	lds	r18, 0x0254	; 0x800254 <ErrorLCD>
     498:	21 11       	cpse	r18, r1
     49a:	30 c0       	rjmp	.+96     	; 0x4fc <LCD_PutChar+0x82>
	{
		/*si l'affichage pas remplie*/
		if (actual_Val_Char < buffer_SIZE)
     49c:	90 32       	cpi	r25, 0x20	; 32
     49e:	70 f5       	brcc	.+92     	; 0x4fc <LCD_PutChar+0x82>
     4a0:	c8 2f       	mov	r28, r24
		{
			/*ligne suivante si la premiere est remplie*/
			if (actual_Val_Char == MAXCHAR_LINE_1_LINE && DISPLAY_MODE == 1)
     4a2:	90 31       	cpi	r25, 0x10	; 16
     4a4:	21 f4       	brne	.+8      	; 0x4ae <LCD_PutChar+0x34>
			{
				LCD_setCursor(1,0);
     4a6:	60 e0       	ldi	r22, 0x00	; 0
     4a8:	81 e0       	ldi	r24, 0x01	; 1
     4aa:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
				#endif
			}
			
			/*ajoute la nouvel valeur dans le circular buffer a la 
			position head_Index*/
			buffer_str[str_buffer_head] = C;
     4ae:	90 91 32 02 	lds	r25, 0x0232	; 0x800232 <str_buffer_head>
     4b2:	89 2f       	mov	r24, r25
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	fc 01       	movw	r30, r24
     4b8:	ed 5c       	subi	r30, 0xCD	; 205
     4ba:	fd 4f       	sbci	r31, 0xFD	; 253
     4bc:	c0 83       	st	Z, r28
			str_buffer_head = (str_buffer_head + 1) % buffer_SIZE;
     4be:	01 96       	adiw	r24, 0x01	; 1
     4c0:	20 91 55 02 	lds	r18, 0x0255	; 0x800255 <buffer_SIZE>
     4c4:	30 e0       	ldi	r19, 0x00	; 0
     4c6:	b9 01       	movw	r22, r18
     4c8:	0e 94 0b 08 	call	0x1016	; 0x1016 <__divmodhi4>
     4cc:	80 93 32 02 	sts	0x0232, r24	; 0x800232 <str_buffer_head>
			
			/*isole char par char a la valeur tail_Index a envoyer*/
			data = buffer_str[str_buffer_tail];
     4d0:	80 91 31 02 	lds	r24, 0x0231	; 0x800231 <str_buffer_tail>
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	fc 01       	movw	r30, r24
     4d8:	ed 5c       	subi	r30, 0xCD	; 205
     4da:	fd 4f       	sbci	r31, 0xFD	; 253
     4dc:	40 81       	ld	r20, Z
			str_buffer_tail = (str_buffer_tail + 1) % buffer_SIZE;
     4de:	01 96       	adiw	r24, 0x01	; 1
     4e0:	b9 01       	movw	r22, r18
     4e2:	0e 94 0b 08 	call	0x1016	; 0x1016 <__divmodhi4>
     4e6:	80 93 31 02 	sts	0x0231, r24	; 0x800231 <str_buffer_tail>
			
			/*affiche le char isoler*/
			LCD_SendInstruction(data,1);
     4ea:	61 e0       	ldi	r22, 0x01	; 1
     4ec:	84 2f       	mov	r24, r20
     4ee:	0e 94 c6 01 	call	0x38c	; 0x38c <LCD_SendInstruction>

			actual_Val_Char++;
     4f2:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <actual_Val_Char>
     4f6:	8f 5f       	subi	r24, 0xFF	; 255
     4f8:	80 93 53 02 	sts	0x0253, r24	; 0x800253 <actual_Val_Char>
			}
		}
	}
	
	return ErrorLCD;
}
     4fc:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <ErrorLCD>
     500:	cf 91       	pop	r28
     502:	08 95       	ret

00000504 <LCD_PutString>:
	si pas d'erreur envois des caractere à la fonction LCD_PutChar
	
	l'erreur est pris en comppte que si le défilement n'est pas activer 
*/
uint8_t LCD_PutString(char *string)
{		
     504:	0f 93       	push	r16
     506:	1f 93       	push	r17
     508:	cf 93       	push	r28
     50a:	df 93       	push	r29
	/*savoir le nombre de char*/
	strLength = strlen((const char *) string);
     50c:	fc 01       	movw	r30, r24
     50e:	01 90       	ld	r0, Z+
     510:	00 20       	and	r0, r0
     512:	e9 f7       	brne	.-6      	; 0x50e <LCD_PutString+0xa>
     514:	31 97       	sbiw	r30, 0x01	; 1
     516:	e8 1b       	sub	r30, r24
     518:	f9 0b       	sbc	r31, r25
     51a:	e0 93 30 02 	sts	0x0230, r30	; 0x800230 <strLength>
	{
		if (strLength > MAXCHAR_LINE_1_LINE && DISPLAY_MODE == 0)
		{
			ErrorLCD |= ERROR_HIGH_LENGH_CHAR;
		}
		if (strLength > MAXCHAR_LINE_2_LINE && DISPLAY_MODE == 1)
     51e:	e1 32       	cpi	r30, 0x21	; 33
     520:	28 f0       	brcs	.+10     	; 0x52c <LCD_PutString+0x28>
		{
			ErrorLCD |= ERROR_HIGH_LENGH_CHAR;
     522:	20 91 54 02 	lds	r18, 0x0254	; 0x800254 <ErrorLCD>
     526:	24 60       	ori	r18, 0x04	; 4
     528:	20 93 54 02 	sts	0x0254, r18	; 0x800254 <ErrorLCD>
		}
	}
	
	/*si pas d'erreur traite char by char*/
	if (ErrorLCD == 0)
     52c:	20 91 54 02 	lds	r18, 0x0254	; 0x800254 <ErrorLCD>
     530:	22 23       	and	r18, r18
     532:	49 f0       	breq	.+18     	; 0x546 <LCD_PutString+0x42>
     534:	11 c0       	rjmp	.+34     	; 0x558 <LCD_PutString+0x54>
	{
		for (int i = 0; i < strLength; i++)
		{	
			LCD_PutChar(string[i]);
     536:	f8 01       	movw	r30, r16
     538:	ec 0f       	add	r30, r28
     53a:	fd 1f       	adc	r31, r29
     53c:	80 81       	ld	r24, Z
     53e:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_PutChar>
	}
	
	/*si pas d'erreur traite char by char*/
	if (ErrorLCD == 0)
	{
		for (int i = 0; i < strLength; i++)
     542:	21 96       	adiw	r28, 0x01	; 1
     544:	03 c0       	rjmp	.+6      	; 0x54c <LCD_PutString+0x48>
     546:	8c 01       	movw	r16, r24
     548:	c0 e0       	ldi	r28, 0x00	; 0
     54a:	d0 e0       	ldi	r29, 0x00	; 0
     54c:	20 91 30 02 	lds	r18, 0x0230	; 0x800230 <strLength>
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	c2 17       	cp	r28, r18
     554:	d3 07       	cpc	r29, r19
     556:	7c f3       	brlt	.-34     	; 0x536 <LCD_PutString+0x32>
			LCD_PutChar(string[i]);
		}
	}
	
	return ErrorLCD;	
}
     558:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <ErrorLCD>
     55c:	df 91       	pop	r29
     55e:	cf 91       	pop	r28
     560:	1f 91       	pop	r17
     562:	0f 91       	pop	r16
     564:	08 95       	ret

00000566 <LCD_Clear>:
}

/*clear le LCD et met a la position X=0 Y=0 le cursor*/
void LCD_Clear(void)
{
	LCD_SendInstruction(0x01,0);
     566:	60 e0       	ldi	r22, 0x00	; 0
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	0e 94 c6 01 	call	0x38c	; 0x38c <LCD_SendInstruction>
	
	actual_Val_Char = 0;
     56e:	10 92 53 02 	sts	0x0253, r1	; 0x800253 <actual_Val_Char>
     572:	08 95       	ret

00000574 <__vector_6>:

uint8_t overflowWhileMeasurement = 0;
uint8_t computeNewTimeBase = 0;

ISR(WDT_vect)
{
     574:	1f 92       	push	r1
     576:	0f 92       	push	r0
     578:	0f b6       	in	r0, 0x3f	; 63
     57a:	0f 92       	push	r0
     57c:	11 24       	eor	r1, r1
     57e:	2f 93       	push	r18
     580:	3f 93       	push	r19
     582:	4f 93       	push	r20
     584:	5f 93       	push	r21
     586:	6f 93       	push	r22
     588:	7f 93       	push	r23
     58a:	8f 93       	push	r24
     58c:	9f 93       	push	r25
     58e:	af 93       	push	r26
     590:	bf 93       	push	r27
     592:	ef 93       	push	r30
     594:	ff 93       	push	r31
	if (WDT_flag == 1)
     596:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <WDT_flag>
     59a:	81 30       	cpi	r24, 0x01	; 1
     59c:	e9 f4       	brne	.+58     	; 0x5d8 <__vector_6+0x64>
	{
		LCD_Clear();
     59e:	0e 94 b3 02 	call	0x566	; 0x566 <LCD_Clear>
		LCD_setCursor(0,0);
     5a2:	60 e0       	ldi	r22, 0x00	; 0
     5a4:	80 e0       	ldi	r24, 0x00	; 0
     5a6:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
		LCD_PutString("trop lent");
     5aa:	8a e0       	ldi	r24, 0x0A	; 10
     5ac:	91 e0       	ldi	r25, 0x01	; 1
     5ae:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
		LCD_setCursor(1,0);
     5b2:	60 e0       	ldi	r22, 0x00	; 0
     5b4:	81 e0       	ldi	r24, 0x01	; 1
     5b6:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
		LCD_PutString("temp MAX atteint");
     5ba:	84 e1       	ldi	r24, 0x14	; 20
     5bc:	91 e0       	ldi	r25, 0x01	; 1
     5be:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
		WDT_flag = 0;
     5c2:	10 92 60 02 	sts	0x0260, r1	; 0x800260 <WDT_flag>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     5c6:	2f ef       	ldi	r18, 0xFF	; 255
     5c8:	87 ea       	ldi	r24, 0xA7	; 167
     5ca:	91 e6       	ldi	r25, 0x61	; 97
     5cc:	21 50       	subi	r18, 0x01	; 1
     5ce:	80 40       	sbci	r24, 0x00	; 0
     5d0:	90 40       	sbci	r25, 0x00	; 0
     5d2:	e1 f7       	brne	.-8      	; 0x5cc <__vector_6+0x58>
     5d4:	00 c0       	rjmp	.+0      	; 0x5d6 <__vector_6+0x62>
     5d6:	00 00       	nop
		_delay_ms(2000);
	}
}
     5d8:	ff 91       	pop	r31
     5da:	ef 91       	pop	r30
     5dc:	bf 91       	pop	r27
     5de:	af 91       	pop	r26
     5e0:	9f 91       	pop	r25
     5e2:	8f 91       	pop	r24
     5e4:	7f 91       	pop	r23
     5e6:	6f 91       	pop	r22
     5e8:	5f 91       	pop	r21
     5ea:	4f 91       	pop	r20
     5ec:	3f 91       	pop	r19
     5ee:	2f 91       	pop	r18
     5f0:	0f 90       	pop	r0
     5f2:	0f be       	out	0x3f, r0	; 63
     5f4:	0f 90       	pop	r0
     5f6:	1f 90       	pop	r1
     5f8:	18 95       	reti

000005fa <__vector_13>:

ISR (TIMER1_OVF_vect)
{
     5fa:	1f 92       	push	r1
     5fc:	0f 92       	push	r0
     5fe:	0f b6       	in	r0, 0x3f	; 63
     600:	0f 92       	push	r0
     602:	11 24       	eor	r1, r1
     604:	8f 93       	push	r24
     606:	9f 93       	push	r25
	if (overflowWhileMeasurement == 0)
     608:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <overflowWhileMeasurement>
     60c:	81 11       	cpse	r24, r1
     60e:	09 c0       	rjmp	.+18     	; 0x622 <__vector_13+0x28>
	{
		if (firstCapture != 0x0000)
     610:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <firstCapture>
     614:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <firstCapture+0x1>
     618:	89 2b       	or	r24, r25
     61a:	19 f0       	breq	.+6      	; 0x622 <__vector_13+0x28>
		{
			overflowWhileMeasurement = 1;
     61c:	81 e0       	ldi	r24, 0x01	; 1
     61e:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <overflowWhileMeasurement>
		else
		{
			/**/
		}
	}
}
     622:	9f 91       	pop	r25
     624:	8f 91       	pop	r24
     626:	0f 90       	pop	r0
     628:	0f be       	out	0x3f, r0	; 63
     62a:	0f 90       	pop	r0
     62c:	1f 90       	pop	r1
     62e:	18 95       	reti

00000630 <__vector_10>:
/*interuption capture 
  2 détection 
  la premiére par L'ACO quand les leds s'éteigne
  la deuxiéme par le flanc montant du SW*/
ISR(TIMER1_CAPT_vect)
{
     630:	1f 92       	push	r1
     632:	0f 92       	push	r0
     634:	0f b6       	in	r0, 0x3f	; 63
     636:	0f 92       	push	r0
     638:	11 24       	eor	r1, r1
     63a:	2f 93       	push	r18
     63c:	8f 93       	push	r24
     63e:	9f 93       	push	r25
	if (flag_secu >= 1)
     640:	80 91 61 02 	lds	r24, 0x0261	; 0x800261 <flag_secu>
     644:	88 23       	and	r24, r24
     646:	c1 f1       	breq	.+112    	; 0x6b8 <__vector_10+0x88>
	{
		/*debug*/
		//PORTD ^= 0x04;
		
		/* Deactivate all interrupt, must be quick */
		cli();
     648:	f8 94       	cli
		/* if interrupt occured for starting a measurement, check for actual time */
		/* if time base was fast, new measurement could be longer --> reset OCR1A */
		/* if capture at rising edge already done, the interrupt must occure for */
		/* the falling edge --> Save ICR1 and ask for a new time base. */
		
		if (firstCapture == 0x0000)
     64a:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <firstCapture>
     64e:	90 91 5b 02 	lds	r25, 0x025B	; 0x80025b <firstCapture+0x1>
     652:	89 2b       	or	r24, r25
     654:	e1 f4       	brne	.+56     	; 0x68e <__vector_10+0x5e>
		{
			firstCapture = ICR1;
     656:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     65a:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     65e:	90 93 5b 02 	sts	0x025B, r25	; 0x80025b <firstCapture+0x1>
     662:	80 93 5a 02 	sts	0x025A, r24	; 0x80025a <firstCapture>
			
			ACSR &= ~(1 << ACIC);
     666:	80 b7       	in	r24, 0x30	; 48
     668:	8b 7f       	andi	r24, 0xFB	; 251
     66a:	80 bf       	out	0x30, r24	; 48
			
			/* Checking if a faster time base was set. */
			if (actualScore < 0xFFFF)
     66c:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <actualScore>
     670:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <actualScore+0x1>
     674:	01 96       	adiw	r24, 0x01	; 1
     676:	b1 f0       	breq	.+44     	; 0x6a4 <__vector_10+0x74>
			{
				actualScore = 0xFFFF;
     678:	8f ef       	ldi	r24, 0xFF	; 255
     67a:	9f ef       	ldi	r25, 0xFF	; 255
     67c:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <actualScore+0x1>
     680:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <actualScore>
				OCR1A = 0xFFFF;
     684:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     688:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
     68c:	0b c0       	rjmp	.+22     	; 0x6a4 <__vector_10+0x74>
			}
		}
		else
		{
			secondCapture = ICR1;
     68e:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     692:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     696:	90 93 59 02 	sts	0x0259, r25	; 0x800259 <secondCapture+0x1>
     69a:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <secondCapture>
			computeNewTimeBase = 1;
     69e:	81 e0       	ldi	r24, 0x01	; 1
     6a0:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <computeNewTimeBase>
     6a4:	8f ed       	ldi	r24, 0xDF	; 223
     6a6:	9e e2       	ldi	r25, 0x2E	; 46
     6a8:	01 97       	sbiw	r24, 0x01	; 1
     6aa:	f1 f7       	brne	.-4      	; 0x6a8 <__vector_10+0x78>
     6ac:	00 c0       	rjmp	.+0      	; 0x6ae <__vector_10+0x7e>
     6ae:	00 00       	nop
		}
		
		_delay_ms(3);
		TIFR1 |= (1 << ICF1);
     6b0:	86 b3       	in	r24, 0x16	; 22
     6b2:	80 62       	ori	r24, 0x20	; 32
     6b4:	86 bb       	out	0x16, r24	; 22
		sei();
     6b6:	78 94       	sei
	}
	
	flag_secu++;
     6b8:	80 91 61 02 	lds	r24, 0x0261	; 0x800261 <flag_secu>
     6bc:	8f 5f       	subi	r24, 0xFF	; 255
     6be:	80 93 61 02 	sts	0x0261, r24	; 0x800261 <flag_secu>
}
     6c2:	9f 91       	pop	r25
     6c4:	8f 91       	pop	r24
     6c6:	2f 91       	pop	r18
     6c8:	0f 90       	pop	r0
     6ca:	0f be       	out	0x3f, r0	; 63
     6cc:	0f 90       	pop	r0
     6ce:	1f 90       	pop	r1
     6d0:	18 95       	reti

000006d2 <sortie>:

/*fonction sortie gpio pour compteur start*/
void sortie (int valeur)
{
	PORTC = valeur & 0x0F;
     6d2:	98 2f       	mov	r25, r24
     6d4:	9f 70       	andi	r25, 0x0F	; 15
     6d6:	98 b9       	out	0x08, r25	; 8
	PORTD = (valeur & 0xF0);
     6d8:	80 7f       	andi	r24, 0xF0	; 240
     6da:	8b b9       	out	0x0b, r24	; 11
     6dc:	08 95       	ret

000006de <Init_Timer>:
}

/*------------timer CTC input capture--------------*/
void Init_Timer (void)
{
	OCR1A = actualScore;
     6de:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <actualScore>
     6e2:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <actualScore+0x1>
     6e6:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     6ea:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
	TCCR1A = 0x00;
     6ee:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
	
	TCCR1B = 0x00;
     6f2:	e1 e8       	ldi	r30, 0x81	; 129
     6f4:	f0 e0       	ldi	r31, 0x00	; 0
     6f6:	10 82       	st	Z, r1
	TCCR1B |= 0b11001101;
     6f8:	80 81       	ld	r24, Z
     6fa:	8d 6c       	ori	r24, 0xCD	; 205
     6fc:	80 83       	st	Z, r24

	TIMSK1 = 0x00;
     6fe:	ef e6       	ldi	r30, 0x6F	; 111
     700:	f0 e0       	ldi	r31, 0x00	; 0
     702:	10 82       	st	Z, r1
	TIMSK1 |= ((1 << TOIE1) | (1 << ICIE1));
     704:	80 81       	ld	r24, Z
     706:	81 62       	ori	r24, 0x21	; 33
     708:	80 83       	st	Z, r24
     70a:	08 95       	ret

0000070c <reset_Score>:
/*reset le score
  le score quand il est reset il est maximum possible donc 4s
  4s car le watch dog timer reset automatiquement si le personne
  n'appuis pas pendant au bout de 4 sec*/
void reset_Score (void)
{
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
	bestScore = 4000;
     710:	80 ea       	ldi	r24, 0xA0	; 160
     712:	9f e0       	ldi	r25, 0x0F	; 15
     714:	90 93 63 02 	sts	0x0263, r25	; 0x800263 <bestScore+0x1>
     718:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <bestScore>
	for (int j = 0; j < 17; j++)
     71c:	c0 e0       	ldi	r28, 0x00	; 0
     71e:	d0 e0       	ldi	r29, 0x00	; 0
     720:	05 c0       	rjmp	.+10     	; 0x72c <reset_Score+0x20>
	{
		eeprom_write_byte((uint8_t *)j,0);
     722:	60 e0       	ldi	r22, 0x00	; 0
     724:	ce 01       	movw	r24, r28
     726:	0e 94 4a 0b 	call	0x1694	; 0x1694 <eeprom_write_byte>
  4s car le watch dog timer reset automatiquement si le personne
  n'appuis pas pendant au bout de 4 sec*/
void reset_Score (void)
{
	bestScore = 4000;
	for (int j = 0; j < 17; j++)
     72a:	21 96       	adiw	r28, 0x01	; 1
     72c:	c1 31       	cpi	r28, 0x11	; 17
     72e:	d1 05       	cpc	r29, r1
     730:	c4 f3       	brlt	.-16     	; 0x722 <reset_Score+0x16>
	{
		eeprom_write_byte((uint8_t *)j,0);
	}
}
     732:	df 91       	pop	r29
     734:	cf 91       	pop	r28
     736:	08 95       	ret

00000738 <main>:

int main(void)
{	
	DDRC = 0x0F;
     738:	8f e0       	ldi	r24, 0x0F	; 15
     73a:	87 b9       	out	0x07, r24	; 7
	DDRD = 0xF6;
     73c:	86 ef       	ldi	r24, 0xF6	; 246
     73e:	8a b9       	out	0x0a, r24	; 10
	DDRB = 0x22;
     740:	82 e2       	ldi	r24, 0x22	; 34
     742:	84 b9       	out	0x04, r24	; 4
	
	sortie(0);
     744:	80 e0       	ldi	r24, 0x00	; 0
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	0e 94 69 03 	call	0x6d2	; 0x6d2 <sortie>
	
	/*pour temp aléatoire avec fonction rand()*/
	srand(42);
     74c:	8a e2       	ldi	r24, 0x2A	; 42
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	0e 94 84 08 	call	0x1108	; 0x1108 <srand>

	wdt_reset(); 
     754:	a8 95       	wdr
	WDTCSR |= (1 << WDCE) | (1 << WDE);
     756:	e0 e6       	ldi	r30, 0x60	; 96
     758:	f0 e0       	ldi	r31, 0x00	; 0
     75a:	80 81       	ld	r24, Z
     75c:	88 61       	ori	r24, 0x18	; 24
     75e:	80 83       	st	Z, r24
	WDTCSR = ((1 << WDIE) | (1 << WDE) | (1 << WDP3));
     760:	88 e6       	ldi	r24, 0x68	; 104
     762:	80 83       	st	Z, r24
	
	Init_Timer();
     764:	0e 94 6f 03 	call	0x6de	; 0x6de <Init_Timer>
	
	sei();
     768:	78 94       	sei
	
	TWIMaster_Init();
     76a:	0e 94 2d 06 	call	0xc5a	; 0xc5a <TWIMaster_Init>
	UART_Init();
     76e:	0e 94 53 00 	call	0xa6	; 0xa6 <UART_Init>
	
	/*affichage LCD*/
	LCD_Init(0x09,0x25);
     772:	65 e2       	ldi	r22, 0x25	; 37
     774:	89 e0       	ldi	r24, 0x09	; 9
     776:	0e 94 1e 01 	call	0x23c	; 0x23c <LCD_Init>
	
	/*si le la pinb1 est préalablement mis a un avant de reset atmega328
	  le best score se reset*/
	if (PINB & (1 << PINB1))
     77a:	19 9b       	sbis	0x03, 1	; 3
     77c:	1f c0       	rjmp	.+62     	; 0x7bc <main+0x84>
	{
		reset_Score();
     77e:	0e 94 86 03 	call	0x70c	; 0x70c <reset_Score>
		LCD_setCursor(0,5);
     782:	65 e0       	ldi	r22, 0x05	; 5
     784:	80 e0       	ldi	r24, 0x00	; 0
     786:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
		LCD_PutString("reset!");
     78a:	85 e2       	ldi	r24, 0x25	; 37
     78c:	91 e0       	ldi	r25, 0x01	; 1
     78e:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
		LCD_setCursor(1,5);
     792:	65 e0       	ldi	r22, 0x05	; 5
     794:	81 e0       	ldi	r24, 0x01	; 1
     796:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
		LCD_PutString("score!");
     79a:	8c e2       	ldi	r24, 0x2C	; 44
     79c:	91 e0       	ldi	r25, 0x01	; 1
     79e:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
     7a2:	2f ef       	ldi	r18, 0xFF	; 255
     7a4:	87 ea       	ldi	r24, 0xA7	; 167
     7a6:	91 e6       	ldi	r25, 0x61	; 97
     7a8:	21 50       	subi	r18, 0x01	; 1
     7aa:	80 40       	sbci	r24, 0x00	; 0
     7ac:	90 40       	sbci	r25, 0x00	; 0
     7ae:	e1 f7       	brne	.-8      	; 0x7a8 <main+0x70>
     7b0:	00 c0       	rjmp	.+0      	; 0x7b2 <main+0x7a>
     7b2:	00 00       	nop
		_delay_ms(2000);
		wdt_reset();
     7b4:	a8 95       	wdr
		flag_resetScore = 1;
     7b6:	81 e0       	ldi	r24, 0x01	; 1
     7b8:	80 93 5f 02 	sts	0x025F, r24	; 0x80025f <flag_resetScore>
	}
	
	LCD_Clear();
     7bc:	0e 94 b3 02 	call	0x566	; 0x566 <LCD_Clear>
	LCD_setCursor(0,0);
     7c0:	60 e0       	ldi	r22, 0x00	; 0
     7c2:	80 e0       	ldi	r24, 0x00	; 0
     7c4:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
	LCD_PutString("Reflex Game BOA");
     7c8:	83 e3       	ldi	r24, 0x33	; 51
     7ca:	91 e0       	ldi	r25, 0x01	; 1
     7cc:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
	
	LCD_setCursor(1,0);
     7d0:	60 e0       	ldi	r22, 0x00	; 0
     7d2:	81 e0       	ldi	r24, 0x01	; 1
     7d4:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
	LCD_PutString("Make a pulse :)");
     7d8:	83 e4       	ldi	r24, 0x43	; 67
     7da:	91 e0       	ldi	r25, 0x01	; 1
     7dc:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
	
	/*prend le best score mis en mémoire dans l'EEPROM*/
	for (int j = 0; j < 17; j++)
     7e0:	c0 e0       	ldi	r28, 0x00	; 0
     7e2:	d0 e0       	ldi	r29, 0x00	; 0
     7e4:	0e c0       	rjmp	.+28     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
	{
		bestScore = bestScore + eeprom_read_byte((uint8_t *)j);
     7e6:	ce 01       	movw	r24, r28
     7e8:	0e 94 42 0b 	call	0x1684	; 0x1684 <eeprom_read_byte>
     7ec:	20 91 62 02 	lds	r18, 0x0262	; 0x800262 <bestScore>
     7f0:	30 91 63 02 	lds	r19, 0x0263	; 0x800263 <bestScore+0x1>
     7f4:	28 0f       	add	r18, r24
     7f6:	31 1d       	adc	r19, r1
     7f8:	30 93 63 02 	sts	0x0263, r19	; 0x800263 <bestScore+0x1>
     7fc:	20 93 62 02 	sts	0x0262, r18	; 0x800262 <bestScore>
	
	LCD_setCursor(1,0);
	LCD_PutString("Make a pulse :)");
	
	/*prend le best score mis en mémoire dans l'EEPROM*/
	for (int j = 0; j < 17; j++)
     800:	21 96       	adiw	r28, 0x01	; 1
     802:	c1 31       	cpi	r28, 0x11	; 17
     804:	d1 05       	cpc	r29, r1
     806:	7c f3       	brlt	.-34     	; 0x7e6 <main+0xae>
	{
		bestScore = bestScore + eeprom_read_byte((uint8_t *)j);
	}
	
	flag_secu = 0;
     808:	10 92 61 02 	sts	0x0261, r1	; 0x800261 <flag_secu>
	
	/*input capture via ACO*/
	/*si ACIC = 1, ICP1 n'est pas détecter*/
	ACSR |= (1 << ACBG);
     80c:	80 b7       	in	r24, 0x30	; 48
     80e:	80 64       	ori	r24, 0x40	; 64
     810:	80 bf       	out	0x30, r24	; 48
	ACSR |= (1 << ACIS1);
     812:	80 b7       	in	r24, 0x30	; 48
     814:	82 60       	ori	r24, 0x02	; 2
     816:	80 bf       	out	0x30, r24	; 48
	
	wdt_reset();
     818:	a8 95       	wdr
	
    /* Replace with your application code */
    while (1) 
    {
		switch (FlagGame)
     81a:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <FlagGame>
     81e:	81 30       	cpi	r24, 0x01	; 1
     820:	09 f4       	brne	.+2      	; 0x824 <__DATA_REGION_LENGTH__+0x24>
     822:	63 c0       	rjmp	.+198    	; 0x8ea <__DATA_REGION_LENGTH__+0xea>
     824:	20 f0       	brcs	.+8      	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
     826:	82 30       	cpi	r24, 0x02	; 2
     828:	09 f4       	brne	.+2      	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
     82a:	e8 c0       	rjmp	.+464    	; 0x9fc <__stack+0xfd>
     82c:	f6 cf       	rjmp	.-20     	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
		{
		case START:
		
			if (WDT_flag == 0)
     82e:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <WDT_flag>
     832:	81 11       	cpse	r24, r1
     834:	01 c0       	rjmp	.+2      	; 0x838 <__DATA_REGION_LENGTH__+0x38>
			{
				wdt_reset();
     836:	a8 95       	wdr
			}
		
			/*empeche que l'activation du bouton pour le lancement du jeux 
			  lance une interuption
			  et permet l'input capture par ACO*/
			ACSR |= (1 << ACIC);
     838:	80 b7       	in	r24, 0x30	; 48
     83a:	84 60       	ori	r24, 0x04	; 4
     83c:	80 bf       	out	0x30, r24	; 48
			
			/*lance le jeux*/
			if (PINB & (1 << PINB0))
     83e:	18 9b       	sbis	0x03, 0	; 3
     840:	ec cf       	rjmp	.-40     	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
			{
				sei();
     842:	78 94       	sei
				
				/*affichage LCD*/
				LCD_Clear();
     844:	0e 94 b3 02 	call	0x566	; 0x566 <LCD_Clear>
				LCD_setCursor(0,0);
     848:	60 e0       	ldi	r22, 0x00	; 0
     84a:	80 e0       	ldi	r24, 0x00	; 0
     84c:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
				LCD_PutString("The Game Start !");
     850:	83 e5       	ldi	r24, 0x53	; 83
     852:	91 e0       	ldi	r25, 0x01	; 1
     854:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
				
				LCD_setCursor(1,0);
     858:	60 e0       	ldi	r22, 0x00	; 0
     85a:	81 e0       	ldi	r24, 0x01	; 1
     85c:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
				LCD_PutString("Best Score :");
     860:	84 e6       	ldi	r24, 0x64	; 100
     862:	91 e0       	ldi	r25, 0x01	; 1
     864:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
				if (flag_resetScore == 0)
     868:	80 91 5f 02 	lds	r24, 0x025F	; 0x80025f <flag_resetScore>
     86c:	81 11       	cpse	r24, r1
     86e:	17 c0       	rjmp	.+46     	; 0x89e <__DATA_REGION_LENGTH__+0x9e>
				{
					sprintf(lcdMsg, "%4d", bestScore);
     870:	80 91 63 02 	lds	r24, 0x0263	; 0x800263 <bestScore+0x1>
     874:	8f 93       	push	r24
     876:	80 91 62 02 	lds	r24, 0x0262	; 0x800262 <bestScore>
     87a:	8f 93       	push	r24
     87c:	81 e7       	ldi	r24, 0x71	; 113
     87e:	91 e0       	ldi	r25, 0x01	; 1
     880:	9f 93       	push	r25
     882:	8f 93       	push	r24
     884:	84 e7       	ldi	r24, 0x74	; 116
     886:	92 e0       	ldi	r25, 0x02	; 2
     888:	9f 93       	push	r25
     88a:	8f 93       	push	r24
     88c:	0e 94 8f 08 	call	0x111e	; 0x111e <sprintf>
     890:	0f 90       	pop	r0
     892:	0f 90       	pop	r0
     894:	0f 90       	pop	r0
     896:	0f 90       	pop	r0
     898:	0f 90       	pop	r0
     89a:	0f 90       	pop	r0
     89c:	12 c0       	rjmp	.+36     	; 0x8c2 <__DATA_REGION_LENGTH__+0xc2>
				}
				else
				{
					sprintf(lcdMsg, "%4d", 0);
     89e:	1f 92       	push	r1
     8a0:	1f 92       	push	r1
     8a2:	81 e7       	ldi	r24, 0x71	; 113
     8a4:	91 e0       	ldi	r25, 0x01	; 1
     8a6:	9f 93       	push	r25
     8a8:	8f 93       	push	r24
     8aa:	84 e7       	ldi	r24, 0x74	; 116
     8ac:	92 e0       	ldi	r25, 0x02	; 2
     8ae:	9f 93       	push	r25
     8b0:	8f 93       	push	r24
     8b2:	0e 94 8f 08 	call	0x111e	; 0x111e <sprintf>
     8b6:	0f 90       	pop	r0
     8b8:	0f 90       	pop	r0
     8ba:	0f 90       	pop	r0
     8bc:	0f 90       	pop	r0
     8be:	0f 90       	pop	r0
     8c0:	0f 90       	pop	r0
				}
				
				LCD_PutString(lcdMsg);
     8c2:	84 e7       	ldi	r24, 0x74	; 116
     8c4:	92 e0       	ldi	r25, 0x02	; 2
     8c6:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
     8ca:	2f ef       	ldi	r18, 0xFF	; 255
     8cc:	87 ea       	ldi	r24, 0xA7	; 167
     8ce:	91 e6       	ldi	r25, 0x61	; 97
     8d0:	21 50       	subi	r18, 0x01	; 1
     8d2:	80 40       	sbci	r24, 0x00	; 0
     8d4:	90 40       	sbci	r25, 0x00	; 0
     8d6:	e1 f7       	brne	.-8      	; 0x8d0 <__DATA_REGION_LENGTH__+0xd0>
     8d8:	00 c0       	rjmp	.+0      	; 0x8da <__DATA_REGION_LENGTH__+0xda>
     8da:	00 00       	nop
				
				_delay_ms(2000);
				
				wdt_reset();
     8dc:	a8 95       	wdr
				
				FlagGame = STARTGAME;
     8de:	81 e0       	ldi	r24, 0x01	; 1
     8e0:	80 93 5e 02 	sts	0x025E, r24	; 0x80025e <FlagGame>
				LCD_Clear();
     8e4:	0e 94 b3 02 	call	0x566	; 0x566 <LCD_Clear>
     8e8:	98 cf       	rjmp	.-208    	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
			break;
			
		case STARTGAME:
			/*compteur leds*/
			/*affichage LCD*/
			LCD_setCursor(0,0);
     8ea:	60 e0       	ldi	r22, 0x00	; 0
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
			LCD_PutString("Act. Score :");
     8f2:	85 e7       	ldi	r24, 0x75	; 117
     8f4:	91 e0       	ldi	r25, 0x01	; 1
     8f6:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>

			LCD_setCursor(1,0);
     8fa:	60 e0       	ldi	r22, 0x00	; 0
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
			LCD_PutString("Best Score :");
     902:	84 e6       	ldi	r24, 0x64	; 100
     904:	91 e0       	ldi	r25, 0x01	; 1
     906:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
			if (flag_resetScore == 0)
     90a:	80 91 5f 02 	lds	r24, 0x025F	; 0x80025f <flag_resetScore>
     90e:	81 11       	cpse	r24, r1
     910:	17 c0       	rjmp	.+46     	; 0x940 <__stack+0x41>
			{
				sprintf(lcdMsg, "%4d", bestScore);
     912:	80 91 63 02 	lds	r24, 0x0263	; 0x800263 <bestScore+0x1>
     916:	8f 93       	push	r24
     918:	80 91 62 02 	lds	r24, 0x0262	; 0x800262 <bestScore>
     91c:	8f 93       	push	r24
     91e:	81 e7       	ldi	r24, 0x71	; 113
     920:	91 e0       	ldi	r25, 0x01	; 1
     922:	9f 93       	push	r25
     924:	8f 93       	push	r24
     926:	84 e7       	ldi	r24, 0x74	; 116
     928:	92 e0       	ldi	r25, 0x02	; 2
     92a:	9f 93       	push	r25
     92c:	8f 93       	push	r24
     92e:	0e 94 8f 08 	call	0x111e	; 0x111e <sprintf>
     932:	0f 90       	pop	r0
     934:	0f 90       	pop	r0
     936:	0f 90       	pop	r0
     938:	0f 90       	pop	r0
     93a:	0f 90       	pop	r0
     93c:	0f 90       	pop	r0
     93e:	14 c0       	rjmp	.+40     	; 0x968 <__stack+0x69>
			}
			else
			{
				sprintf(lcdMsg, "%4d", 0);
     940:	1f 92       	push	r1
     942:	1f 92       	push	r1
     944:	81 e7       	ldi	r24, 0x71	; 113
     946:	91 e0       	ldi	r25, 0x01	; 1
     948:	9f 93       	push	r25
     94a:	8f 93       	push	r24
     94c:	84 e7       	ldi	r24, 0x74	; 116
     94e:	92 e0       	ldi	r25, 0x02	; 2
     950:	9f 93       	push	r25
     952:	8f 93       	push	r24
     954:	0e 94 8f 08 	call	0x111e	; 0x111e <sprintf>
				flag_resetScore = 0;
     958:	10 92 5f 02 	sts	0x025F, r1	; 0x80025f <flag_resetScore>
     95c:	0f 90       	pop	r0
     95e:	0f 90       	pop	r0
     960:	0f 90       	pop	r0
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	0f 90       	pop	r0
			}
			
			LCD_PutString(lcdMsg);
     968:	84 e7       	ldi	r24, 0x74	; 116
     96a:	92 e0       	ldi	r25, 0x02	; 2
     96c:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
			
			/*compteur leds*/
			for (int i = 0; i < 4; i++)
     970:	c0 e0       	ldi	r28, 0x00	; 0
     972:	d0 e0       	ldi	r29, 0x00	; 0
     974:	13 c0       	rjmp	.+38     	; 0x99c <__stack+0x9d>
			{
				cli();
     976:	f8 94       	cli
     978:	2f ef       	ldi	r18, 0xFF	; 255
     97a:	8e e9       	ldi	r24, 0x9E	; 158
     97c:	94 e2       	ldi	r25, 0x24	; 36
     97e:	21 50       	subi	r18, 0x01	; 1
     980:	80 40       	sbci	r24, 0x00	; 0
     982:	90 40       	sbci	r25, 0x00	; 0
     984:	e1 f7       	brne	.-8      	; 0x97e <__stack+0x7f>
     986:	00 c0       	rjmp	.+0      	; 0x988 <__stack+0x89>
     988:	00 00       	nop
				_delay_ms(750);	
				sortie(ledStart[i]);	
     98a:	fe 01       	movw	r30, r28
     98c:	ea 5f       	subi	r30, 0xFA	; 250
     98e:	fe 4f       	sbci	r31, 0xFE	; 254
     990:	80 81       	ld	r24, Z
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	0e 94 69 03 	call	0x6d2	; 0x6d2 <sortie>
				wdt_reset();		
     998:	a8 95       	wdr
			}
			
			LCD_PutString(lcdMsg);
			
			/*compteur leds*/
			for (int i = 0; i < 4; i++)
     99a:	21 96       	adiw	r28, 0x01	; 1
     99c:	c4 30       	cpi	r28, 0x04	; 4
     99e:	d1 05       	cpc	r29, r1
     9a0:	54 f3       	brlt	.-44     	; 0x976 <__stack+0x77>
				_delay_ms(750);	
				sortie(ledStart[i]);	
				wdt_reset();		
			}
			
			sei();
     9a2:	78 94       	sei
				calcule :
				prescaler/F_CPU = 1024/16000000 = 0,000064
				500ms -> 0,5/0,000064 = 7812;
				2s	  -> 2/0,000064 = 31250
			*/
			TCNT1 = 0;
     9a4:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     9a8:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
			OCR1A = rand() % 31250 + 7812;
     9ac:	0e 94 7f 08 	call	0x10fe	; 0x10fe <rand>
     9b0:	62 e1       	ldi	r22, 0x12	; 18
     9b2:	7a e7       	ldi	r23, 0x7A	; 122
     9b4:	0e 94 0b 08 	call	0x1016	; 0x1016 <__divmodhi4>
     9b8:	8c 57       	subi	r24, 0x7C	; 124
     9ba:	91 4e       	sbci	r25, 0xE1	; 225
     9bc:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     9c0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
			wdt_reset();
     9c4:	a8 95       	wdr
			while(TCNT1 < OCR1A);
     9c6:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
     9ca:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     9ce:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
     9d2:	90 91 89 00 	lds	r25, 0x0089	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     9d6:	28 17       	cp	r18, r24
     9d8:	39 07       	cpc	r19, r25
     9da:	a8 f3       	brcs	.-22     	; 0x9c6 <__stack+0xc7>
			/*remis valeur max OCR1A pour ravoir létat initiale du timer 
			  pour l'input capture par la suite*/
			OCR1A = 0xFFFF;
     9dc:	8f ef       	ldi	r24, 0xFF	; 255
     9de:	9f ef       	ldi	r25, 0xFF	; 255
     9e0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     9e4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
			
			WDT_flag = 1;
     9e8:	81 e0       	ldi	r24, 0x01	; 1
     9ea:	80 93 60 02 	sts	0x0260, r24	; 0x800260 <WDT_flag>
			wdt_reset();
     9ee:	a8 95       	wdr
			
			FlagGame = SCOREGAME;
     9f0:	82 e0       	ldi	r24, 0x02	; 2
     9f2:	80 93 5e 02 	sts	0x025E, r24	; 0x80025e <FlagGame>
			
			PORTC = 0;
     9f6:	18 b8       	out	0x08, r1	; 8
			PORTD = 0;
     9f8:	1b b8       	out	0x0b, r1	; 11
			
			break;
     9fa:	0f cf       	rjmp	.-482    	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
			
		case SCOREGAME:
			 /*valeur capture
			  mise en eeprom best score
			  */
			if(computeNewTimeBase != 0)
     9fc:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <computeNewTimeBase>
     a00:	88 23       	and	r24, r24
     a02:	09 f4       	brne	.+2      	; 0xa06 <__stack+0x107>
     a04:	0a cf       	rjmp	.-492    	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
			{
				/*empeche n'importe quelle autre appuis du SW de générer une
				  interuption
				  et active la détection par ACO pour une nouvel partie*/
				ACSR |= (1 << ACIC);
     a06:	80 b7       	in	r24, 0x30	; 48
     a08:	84 60       	ori	r24, 0x04	; 4
     a0a:	80 bf       	out	0x30, r24	; 48
				
				if (overflowWhileMeasurement <= 1)
     a0c:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <overflowWhileMeasurement>
     a10:	82 30       	cpi	r24, 0x02	; 2
     a12:	c8 f4       	brcc	.+50     	; 0xa46 <__stack+0x147>
				{
					if (secondCapture > firstCapture)
     a14:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <secondCapture>
     a18:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <secondCapture+0x1>
     a1c:	20 91 5a 02 	lds	r18, 0x025A	; 0x80025a <firstCapture>
     a20:	30 91 5b 02 	lds	r19, 0x025B	; 0x80025b <firstCapture+0x1>
     a24:	28 17       	cp	r18, r24
     a26:	39 07       	cpc	r19, r25
     a28:	38 f4       	brcc	.+14     	; 0xa38 <__stack+0x139>
					{
						actualScore = (secondCapture - firstCapture);
     a2a:	82 1b       	sub	r24, r18
     a2c:	93 0b       	sbc	r25, r19
     a2e:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <actualScore+0x1>
     a32:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <actualScore>
     a36:	07 c0       	rjmp	.+14     	; 0xa46 <__stack+0x147>
					}
					else
					{
						actualScore = ((0xFFFF - firstCapture) + secondCapture);
     a38:	82 1b       	sub	r24, r18
     a3a:	93 0b       	sbc	r25, r19
     a3c:	01 97       	sbiw	r24, 0x01	; 1
     a3e:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <actualScore+0x1>
     a42:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <actualScore>
				  Timer, théoriquement pour savoir cette valeur si ont
				  veux par exemple 500ms sa serais
				  0,5 / 0,000064 = 7812 
				  mais vus que moi je veux le temp je fait une inverison
				  7812 * 0,000064 = 0,5 * 1000 pour 500ms*/
				actualScore = (actualScore * 0.000064) * 1000;
     a46:	60 91 04 01 	lds	r22, 0x0104	; 0x800104 <actualScore>
     a4a:	70 91 05 01 	lds	r23, 0x0105	; 0x800105 <actualScore+0x1>
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	0e 94 10 07 	call	0xe20	; 0xe20 <__floatunsisf>
     a56:	2d eb       	ldi	r18, 0xBD	; 189
     a58:	37 e3       	ldi	r19, 0x37	; 55
     a5a:	46 e8       	ldi	r20, 0x86	; 134
     a5c:	58 e3       	ldi	r21, 0x38	; 56
     a5e:	0e 94 76 07 	call	0xeec	; 0xeec <__mulsf3>
     a62:	20 e0       	ldi	r18, 0x00	; 0
     a64:	30 e0       	ldi	r19, 0x00	; 0
     a66:	4a e7       	ldi	r20, 0x7A	; 122
     a68:	54 e4       	ldi	r21, 0x44	; 68
     a6a:	0e 94 76 07 	call	0xeec	; 0xeec <__mulsf3>
     a6e:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <__fixunssfsi>
     a72:	70 93 05 01 	sts	0x0105, r23	; 0x800105 <actualScore+0x1>
     a76:	60 93 04 01 	sts	0x0104, r22	; 0x800104 <actualScore>
				
				TCNT1 = 0x0000;
     a7a:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     a7e:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
				firstCapture = 0;
     a82:	10 92 5b 02 	sts	0x025B, r1	; 0x80025b <firstCapture+0x1>
     a86:	10 92 5a 02 	sts	0x025A, r1	; 0x80025a <firstCapture>
				secondCapture = 0;
     a8a:	10 92 59 02 	sts	0x0259, r1	; 0x800259 <secondCapture+0x1>
     a8e:	10 92 58 02 	sts	0x0258, r1	; 0x800258 <secondCapture>
				computeNewTimeBase = 0;
     a92:	10 92 56 02 	sts	0x0256, r1	; 0x800256 <computeNewTimeBase>
				overflowWhileMeasurement = 0;
     a96:	10 92 57 02 	sts	0x0257, r1	; 0x800257 <overflowWhileMeasurement>
				
				LCD_Clear();
     a9a:	0e 94 b3 02 	call	0x566	; 0x566 <LCD_Clear>
				LCD_setCursor(0,5);
     a9e:	65 e0       	ldi	r22, 0x05	; 5
     aa0:	80 e0       	ldi	r24, 0x00	; 0
     aa2:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
				
				/*si actualScore et plus petit que le best change le best 
				  score par l'actual et met en mémoire le best score
				  dans l'eeprom*/
				if (actualScore < bestScore)
     aa6:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <actualScore>
     aaa:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <actualScore+0x1>
     aae:	20 91 62 02 	lds	r18, 0x0262	; 0x800262 <bestScore>
     ab2:	30 91 63 02 	lds	r19, 0x0263	; 0x800263 <bestScore+0x1>
     ab6:	82 17       	cp	r24, r18
     ab8:	93 07       	cpc	r25, r19
     aba:	08 f0       	brcs	.+2      	; 0xabe <__stack+0x1bf>
     abc:	64 c0       	rjmp	.+200    	; 0xb86 <__stack+0x287>
				{
					actualScoreSecondaire = actualScore;
     abe:	90 93 5d 02 	sts	0x025D, r25	; 0x80025d <actualScoreSecondaire+0x1>
     ac2:	80 93 5c 02 	sts	0x025C, r24	; 0x80025c <actualScoreSecondaire>
					
					for (int j = 0; j < 17; j++)
     ac6:	c0 e0       	ldi	r28, 0x00	; 0
     ac8:	d0 e0       	ldi	r29, 0x00	; 0
     aca:	05 c0       	rjmp	.+10     	; 0xad6 <__stack+0x1d7>
					{
						eeprom_write_byte((uint8_t *)j,0);
     acc:	60 e0       	ldi	r22, 0x00	; 0
     ace:	ce 01       	movw	r24, r28
     ad0:	0e 94 4a 0b 	call	0x1694	; 0x1694 <eeprom_write_byte>
				  dans l'eeprom*/
				if (actualScore < bestScore)
				{
					actualScoreSecondaire = actualScore;
					
					for (int j = 0; j < 17; j++)
     ad4:	21 96       	adiw	r28, 0x01	; 1
     ad6:	c1 31       	cpi	r28, 0x11	; 17
     ad8:	d1 05       	cpc	r29, r1
     ada:	c4 f3       	brlt	.-16     	; 0xacc <__stack+0x1cd>
     adc:	2a c0       	rjmp	.+84     	; 0xb32 <__stack+0x233>
					/*vus qu'une addresse de l'epprom peux contenir max 255
					  en décimal, je met en mémoire par packet de 255 dans
					  le nombre d'adresse nécaissaire */
					while(actualScoreSecondaire > 0x0000)
					{
						wdt_reset();
     ade:	a8 95       	wdr
						if (actualScoreSecondaire > 255)
     ae0:	6f 3f       	cpi	r22, 0xFF	; 255
     ae2:	71 05       	cpc	r23, r1
     ae4:	e1 f0       	breq	.+56     	; 0xb1e <__stack+0x21f>
     ae6:	d8 f0       	brcs	.+54     	; 0xb1e <__stack+0x21f>
						{
							eeprom_write_byte((uint8_t *)addrEEPROM, 255);
     ae8:	6f ef       	ldi	r22, 0xFF	; 255
     aea:	80 91 64 02 	lds	r24, 0x0264	; 0x800264 <addrEEPROM>
     aee:	90 91 65 02 	lds	r25, 0x0265	; 0x800265 <addrEEPROM+0x1>
     af2:	0e 94 4a 0b 	call	0x1694	; 0x1694 <eeprom_write_byte>
							addrEEPROM++;
     af6:	80 91 64 02 	lds	r24, 0x0264	; 0x800264 <addrEEPROM>
     afa:	90 91 65 02 	lds	r25, 0x0265	; 0x800265 <addrEEPROM+0x1>
     afe:	01 96       	adiw	r24, 0x01	; 1
     b00:	90 93 65 02 	sts	0x0265, r25	; 0x800265 <addrEEPROM+0x1>
     b04:	80 93 64 02 	sts	0x0264, r24	; 0x800264 <addrEEPROM>
							actualScoreSecondaire -= 255;
     b08:	80 91 5c 02 	lds	r24, 0x025C	; 0x80025c <actualScoreSecondaire>
     b0c:	90 91 5d 02 	lds	r25, 0x025D	; 0x80025d <actualScoreSecondaire+0x1>
     b10:	8f 5f       	subi	r24, 0xFF	; 255
     b12:	91 09       	sbc	r25, r1
     b14:	90 93 5d 02 	sts	0x025D, r25	; 0x80025d <actualScoreSecondaire+0x1>
     b18:	80 93 5c 02 	sts	0x025C, r24	; 0x80025c <actualScoreSecondaire>
     b1c:	0a c0       	rjmp	.+20     	; 0xb32 <__stack+0x233>
						}
						else
						{
							eeprom_write_byte((uint8_t *)addrEEPROM, actualScoreSecondaire);
     b1e:	80 91 64 02 	lds	r24, 0x0264	; 0x800264 <addrEEPROM>
     b22:	90 91 65 02 	lds	r25, 0x0265	; 0x800265 <addrEEPROM+0x1>
     b26:	0e 94 4a 0b 	call	0x1694	; 0x1694 <eeprom_write_byte>
							actualScoreSecondaire -= actualScoreSecondaire;
     b2a:	10 92 5d 02 	sts	0x025D, r1	; 0x80025d <actualScoreSecondaire+0x1>
     b2e:	10 92 5c 02 	sts	0x025C, r1	; 0x80025c <actualScoreSecondaire>
					}
					
					/*vus qu'une addresse de l'epprom peux contenir max 255
					  en décimal, je met en mémoire par packet de 255 dans
					  le nombre d'adresse nécaissaire */
					while(actualScoreSecondaire > 0x0000)
     b32:	60 91 5c 02 	lds	r22, 0x025C	; 0x80025c <actualScoreSecondaire>
     b36:	70 91 5d 02 	lds	r23, 0x025D	; 0x80025d <actualScoreSecondaire+0x1>
     b3a:	61 15       	cp	r22, r1
     b3c:	71 05       	cpc	r23, r1
     b3e:	79 f6       	brne	.-98     	; 0xade <__stack+0x1df>
							eeprom_write_byte((uint8_t *)addrEEPROM, actualScoreSecondaire);
							actualScoreSecondaire -= actualScoreSecondaire;
						}
					}
					
					bestScore = 0x0000;
     b40:	10 92 63 02 	sts	0x0263, r1	; 0x800263 <bestScore+0x1>
     b44:	10 92 62 02 	sts	0x0262, r1	; 0x800262 <bestScore>
					
					/*j'additionne les valeur de chaque adresse qui comporte
					  une valeur pour avoir au total le best score */
					for (int j = 0; j < addrEEPROM + 1; j++)
     b48:	c0 e0       	ldi	r28, 0x00	; 0
     b4a:	d0 e0       	ldi	r29, 0x00	; 0
     b4c:	0f c0       	rjmp	.+30     	; 0xb6c <__stack+0x26d>
					{
						bestScore = bestScore + eeprom_read_byte((uint8_t *)j);
     b4e:	ce 01       	movw	r24, r28
     b50:	0e 94 42 0b 	call	0x1684	; 0x1684 <eeprom_read_byte>
     b54:	20 91 62 02 	lds	r18, 0x0262	; 0x800262 <bestScore>
     b58:	30 91 63 02 	lds	r19, 0x0263	; 0x800263 <bestScore+0x1>
     b5c:	28 0f       	add	r18, r24
     b5e:	31 1d       	adc	r19, r1
     b60:	30 93 63 02 	sts	0x0263, r19	; 0x800263 <bestScore+0x1>
     b64:	20 93 62 02 	sts	0x0262, r18	; 0x800262 <bestScore>
						wdt_reset();
     b68:	a8 95       	wdr
					
					bestScore = 0x0000;
					
					/*j'additionne les valeur de chaque adresse qui comporte
					  une valeur pour avoir au total le best score */
					for (int j = 0; j < addrEEPROM + 1; j++)
     b6a:	21 96       	adiw	r28, 0x01	; 1
     b6c:	80 91 64 02 	lds	r24, 0x0264	; 0x800264 <addrEEPROM>
     b70:	90 91 65 02 	lds	r25, 0x0265	; 0x800265 <addrEEPROM+0x1>
     b74:	01 96       	adiw	r24, 0x01	; 1
     b76:	c8 17       	cp	r28, r24
     b78:	d9 07       	cpc	r29, r25
     b7a:	48 f3       	brcs	.-46     	; 0xb4e <__stack+0x24f>
					{
						bestScore = bestScore + eeprom_read_byte((uint8_t *)j);
						wdt_reset();
					}
					
					LCD_PutString("WINNER");
     b7c:	82 e8       	ldi	r24, 0x82	; 130
     b7e:	91 e0       	ldi	r25, 0x01	; 1
     b80:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
     b84:	04 c0       	rjmp	.+8      	; 0xb8e <__stack+0x28f>
				}
				else
				{
					LCD_PutString("LOOSER");
     b86:	89 e8       	ldi	r24, 0x89	; 137
     b88:	91 e0       	ldi	r25, 0x01	; 1
     b8a:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
				}
				
				/*affichage LCD*/
				LCD_setCursor(1,1);
     b8e:	61 e0       	ldi	r22, 0x01	; 1
     b90:	81 e0       	ldi	r24, 0x01	; 1
     b92:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
				LCD_PutString("Score : ");
     b96:	80 e9       	ldi	r24, 0x90	; 144
     b98:	91 e0       	ldi	r25, 0x01	; 1
     b9a:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
				
				LCD_setCursor(1,9);
     b9e:	69 e0       	ldi	r22, 0x09	; 9
     ba0:	81 e0       	ldi	r24, 0x01	; 1
     ba2:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
				sprintf(lcdMsg, "%d", actualScore);
     ba6:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <actualScore+0x1>
     baa:	8f 93       	push	r24
     bac:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <actualScore>
     bb0:	8f 93       	push	r24
     bb2:	89 e9       	ldi	r24, 0x99	; 153
     bb4:	91 e0       	ldi	r25, 0x01	; 1
     bb6:	9f 93       	push	r25
     bb8:	8f 93       	push	r24
     bba:	c4 e7       	ldi	r28, 0x74	; 116
     bbc:	d2 e0       	ldi	r29, 0x02	; 2
     bbe:	df 93       	push	r29
     bc0:	cf 93       	push	r28
     bc2:	0e 94 8f 08 	call	0x111e	; 0x111e <sprintf>
				LCD_PutString(lcdMsg);
     bc6:	ce 01       	movw	r24, r28
     bc8:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
				
				wdt_reset();
     bcc:	a8 95       	wdr
     bce:	9f ef       	ldi	r25, 0xFF	; 255
     bd0:	2b e7       	ldi	r18, 0x7B	; 123
     bd2:	82 e9       	ldi	r24, 0x92	; 146
     bd4:	91 50       	subi	r25, 0x01	; 1
     bd6:	20 40       	sbci	r18, 0x00	; 0
     bd8:	80 40       	sbci	r24, 0x00	; 0
     bda:	e1 f7       	brne	.-8      	; 0xbd4 <__stack+0x2d5>
     bdc:	00 c0       	rjmp	.+0      	; 0xbde <__stack+0x2df>
     bde:	00 00       	nop
				_delay_ms(3000);
				wdt_reset();
     be0:	a8 95       	wdr
				
				LCD_setCursor(0,0);
     be2:	60 e0       	ldi	r22, 0x00	; 0
     be4:	80 e0       	ldi	r24, 0x00	; 0
     be6:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
				LCD_PutString("Act. Score :");
     bea:	85 e7       	ldi	r24, 0x75	; 117
     bec:	91 e0       	ldi	r25, 0x01	; 1
     bee:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
				sprintf(lcdMsg, "%4d", actualScore);
     bf2:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <actualScore+0x1>
     bf6:	8f 93       	push	r24
     bf8:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <actualScore>
     bfc:	8f 93       	push	r24
     bfe:	01 e7       	ldi	r16, 0x71	; 113
     c00:	11 e0       	ldi	r17, 0x01	; 1
     c02:	1f 93       	push	r17
     c04:	0f 93       	push	r16
     c06:	df 93       	push	r29
     c08:	cf 93       	push	r28
     c0a:	0e 94 8f 08 	call	0x111e	; 0x111e <sprintf>
				LCD_PutString(lcdMsg);
     c0e:	ce 01       	movw	r24, r28
     c10:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
				
				LCD_setCursor(1,0);
     c14:	60 e0       	ldi	r22, 0x00	; 0
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	0e 94 11 02 	call	0x422	; 0x422 <LCD_setCursor>
				LCD_PutString("Best Score :");
     c1c:	84 e6       	ldi	r24, 0x64	; 100
     c1e:	91 e0       	ldi	r25, 0x01	; 1
     c20:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
				sprintf(lcdMsg, "%4d", bestScore);
     c24:	80 91 63 02 	lds	r24, 0x0263	; 0x800263 <bestScore+0x1>
     c28:	8f 93       	push	r24
     c2a:	80 91 62 02 	lds	r24, 0x0262	; 0x800262 <bestScore>
     c2e:	8f 93       	push	r24
     c30:	1f 93       	push	r17
     c32:	0f 93       	push	r16
     c34:	df 93       	push	r29
     c36:	cf 93       	push	r28
     c38:	0e 94 8f 08 	call	0x111e	; 0x111e <sprintf>
				LCD_PutString(lcdMsg);
     c3c:	ce 01       	movw	r24, r28
     c3e:	0e 94 82 02 	call	0x504	; 0x504 <LCD_PutString>
				
				cli();
     c42:	f8 94       	cli
				
				FlagGame = START;
     c44:	10 92 5e 02 	sts	0x025E, r1	; 0x80025e <FlagGame>
     c48:	8d b7       	in	r24, 0x3d	; 61
     c4a:	9e b7       	in	r25, 0x3e	; 62
     c4c:	42 96       	adiw	r24, 0x12	; 18
     c4e:	0f b6       	in	r0, 0x3f	; 63
     c50:	f8 94       	cli
     c52:	9e bf       	out	0x3e, r25	; 62
     c54:	0f be       	out	0x3f, r0	; 63
     c56:	8d bf       	out	0x3d, r24	; 61
     c58:	e0 cd       	rjmp	.-1088   	; 0x81a <__DATA_REGION_LENGTH__+0x1a>

00000c5a <TWIMaster_Init>:
}

U_TWI_Status TWI_GetTransmitStatus (void)
{
	return TWI_StatusTxRx;
}
     c5a:	e9 eb       	ldi	r30, 0xB9	; 185
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	80 81       	ld	r24, Z
     c60:	8c 7f       	andi	r24, 0xFC	; 252
     c62:	80 83       	st	Z, r24
     c64:	80 81       	ld	r24, Z
     c66:	80 83       	st	Z, r24
     c68:	80 e2       	ldi	r24, 0x20	; 32
     c6a:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7f80b8>
     c6e:	8f ef       	ldi	r24, 0xFF	; 255
     c70:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
     c74:	ec eb       	ldi	r30, 0xBC	; 188
     c76:	f0 e0       	ldi	r31, 0x00	; 0
     c78:	10 82       	st	Z, r1
     c7a:	84 e0       	ldi	r24, 0x04	; 4
     c7c:	80 83       	st	Z, r24
     c7e:	08 95       	ret

00000c80 <TWIMaster_SendMsg>:
     c80:	fc 01       	movw	r30, r24
     c82:	60 93 68 02 	sts	0x0268, r22	; 0x800268 <TWI_MsgSize>
     c86:	80 81       	ld	r24, Z
     c88:	80 93 69 02 	sts	0x0269, r24	; 0x800269 <TWI_BufferTxRx>
     c8c:	80 81       	ld	r24, Z
     c8e:	80 ff       	sbrs	r24, 0
     c90:	0d c0       	rjmp	.+26     	; 0xcac <TWIMaster_SendMsg+0x2c>
     c92:	0f c0       	rjmp	.+30     	; 0xcb2 <TWIMaster_SendMsg+0x32>
     c94:	29 2f       	mov	r18, r25
     c96:	30 e0       	ldi	r19, 0x00	; 0
     c98:	df 01       	movw	r26, r30
     c9a:	a2 0f       	add	r26, r18
     c9c:	b3 1f       	adc	r27, r19
     c9e:	8c 91       	ld	r24, X
     ca0:	d9 01       	movw	r26, r18
     ca2:	a7 59       	subi	r26, 0x97	; 151
     ca4:	bd 4f       	sbci	r27, 0xFD	; 253
     ca6:	8c 93       	st	X, r24
     ca8:	9f 5f       	subi	r25, 0xFF	; 255
     caa:	01 c0       	rjmp	.+2      	; 0xcae <TWIMaster_SendMsg+0x2e>
     cac:	91 e0       	ldi	r25, 0x01	; 1
     cae:	96 17       	cp	r25, r22
     cb0:	88 f3       	brcs	.-30     	; 0xc94 <TWIMaster_SendMsg+0x14>
     cb2:	10 92 67 02 	sts	0x0267, r1	; 0x800267 <TWI_StatusTxRx>
     cb6:	85 ea       	ldi	r24, 0xA5	; 165
     cb8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
     cbc:	08 95       	ret

00000cbe <__vector_24>:
*	l'interruption envoie les données qui s'y trouvent. 
*
*/

ISR(TWI_vect)
{
     cbe:	1f 92       	push	r1
     cc0:	0f 92       	push	r0
     cc2:	0f b6       	in	r0, 0x3f	; 63
     cc4:	0f 92       	push	r0
     cc6:	11 24       	eor	r1, r1
     cc8:	2f 93       	push	r18
     cca:	3f 93       	push	r19
     ccc:	8f 93       	push	r24
     cce:	9f 93       	push	r25
     cd0:	ef 93       	push	r30
     cd2:	ff 93       	push	r31
	static uint8_t MsgPtr = 0;		// Pointeur de message (Static = 
								// valeur reste après l'interruption)
								
	switch (TWSR)
     cd4:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
     cd8:	88 32       	cpi	r24, 0x28	; 40
     cda:	a1 f0       	breq	.+40     	; 0xd04 <__vector_24+0x46>
     cdc:	40 f4       	brcc	.+16     	; 0xcee <__vector_24+0x30>
     cde:	80 31       	cpi	r24, 0x10	; 16
     ce0:	79 f0       	breq	.+30     	; 0xd00 <__vector_24+0x42>
     ce2:	88 31       	cpi	r24, 0x18	; 24
     ce4:	79 f0       	breq	.+30     	; 0xd04 <__vector_24+0x46>
     ce6:	88 30       	cpi	r24, 0x08	; 8
     ce8:	09 f0       	breq	.+2      	; 0xcec <__vector_24+0x2e>
     cea:	58 c0       	rjmp	.+176    	; 0xd9c <__vector_24+0xde>
     cec:	09 c0       	rjmp	.+18     	; 0xd00 <__vector_24+0x42>
     cee:	80 35       	cpi	r24, 0x50	; 80
     cf0:	31 f1       	breq	.+76     	; 0xd3e <__vector_24+0x80>
     cf2:	88 35       	cpi	r24, 0x58	; 88
     cf4:	09 f4       	brne	.+2      	; 0xcf8 <__vector_24+0x3a>
     cf6:	41 c0       	rjmp	.+130    	; 0xd7a <__vector_24+0xbc>
     cf8:	80 34       	cpi	r24, 0x40	; 64
     cfa:	09 f0       	breq	.+2      	; 0xcfe <__vector_24+0x40>
     cfc:	4f c0       	rjmp	.+158    	; 0xd9c <__vector_24+0xde>
     cfe:	2b c0       	rjmp	.+86     	; 0xd56 <__vector_24+0x98>
	{
		case TWI_START:							// Si une condition de start ou de Repeated start
		case TWI_REP_START:						// a été envoyé, remet le pointeur à "0" et charge 
		MsgPtr = 0;								// l'adresse 
     d00:	10 92 66 02 	sts	0x0266, r1	; 0x800266 <MsgPtr.1690>
		case TWI_WR_ADR_ACK:					// Cette condition s'applique également si l'écriture
		case TWI_WR_DATA_ACK:					// a été notifiée par un ACK 
			if (MsgPtr < TWI_MsgSize)			// Si la totalité n'a pas été envoyée
     d04:	e0 91 66 02 	lds	r30, 0x0266	; 0x800266 <MsgPtr.1690>
     d08:	80 91 68 02 	lds	r24, 0x0268	; 0x800268 <TWI_MsgSize>
     d0c:	e8 17       	cp	r30, r24
     d0e:	70 f4       	brcc	.+28     	; 0xd2c <__vector_24+0x6e>
			{
				TWDR = TWI_BufferTxRx[MsgPtr++];
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	8e 0f       	add	r24, r30
     d14:	80 93 66 02 	sts	0x0266, r24	; 0x800266 <MsgPtr.1690>
     d18:	f0 e0       	ldi	r31, 0x00	; 0
     d1a:	e7 59       	subi	r30, 0x97	; 151
     d1c:	fd 4f       	sbci	r31, 0xFD	; 253
     d1e:	80 81       	ld	r24, Z
     d20:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
				TWCR = (1<<TWEN)|                          // Active le périphérique TWI
     d24:	85 e8       	ldi	r24, 0x85	; 133
     d26:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
     d2a:	40 c0       	rjmp	.+128    	; 0xdac <__vector_24+0xee>
				(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				(0<<TWWC);                                 //
			}
			else								// Si la totalité du message a été envoyée								
			{
				TWI_StatusTxRx.S_StatusBit.TransmitOk = 0x01;	// Règle le bit de status (TX OK) 
     d2c:	80 91 67 02 	lds	r24, 0x0267	; 0x800267 <TWI_StatusTxRx>
     d30:	81 60       	ori	r24, 0x01	; 1
     d32:	80 93 67 02 	sts	0x0267, r24	; 0x800267 <TWI_StatusTxRx>
				TWCR = (1<<TWEN)|									// Active le périphérique TWI
     d36:	84 e9       	ldi	r24, 0x94	; 148
     d38:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
     d3c:	37 c0       	rjmp	.+110    	; 0xdac <__vector_24+0xee>
				(0<<TWWC);											//
			}
		break;
		
    case TWI_RD_DATA_ACK:					// Si un byte a été reçu et ACK envoyé
		TWI_BufferTxRx[MsgPtr++] = TWDR;
     d3e:	e0 91 66 02 	lds	r30, 0x0266	; 0x800266 <MsgPtr.1690>
     d42:	81 e0       	ldi	r24, 0x01	; 1
     d44:	8e 0f       	add	r24, r30
     d46:	80 93 66 02 	sts	0x0266, r24	; 0x800266 <MsgPtr.1690>
     d4a:	f0 e0       	ldi	r31, 0x00	; 0
     d4c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
     d50:	e7 59       	subi	r30, 0x97	; 151
     d52:	fd 4f       	sbci	r31, 0xFD	; 253
     d54:	80 83       	st	Z, r24
		
    case TWI_RD_ADR_ACK:					// L'adresse et la notification ont été reçu par le SLAVE
    if (MsgPtr < (TWI_MsgSize-1) )          // Vérifie si il s'agit du dernier byte à lire 
     d56:	20 91 66 02 	lds	r18, 0x0266	; 0x800266 <MsgPtr.1690>
     d5a:	30 e0       	ldi	r19, 0x00	; 0
     d5c:	80 91 68 02 	lds	r24, 0x0268	; 0x800268 <TWI_MsgSize>
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	01 97       	sbiw	r24, 0x01	; 1
     d64:	28 17       	cp	r18, r24
     d66:	39 07       	cpc	r19, r25
     d68:	24 f4       	brge	.+8      	; 0xd72 <__vector_24+0xb4>
    {
		// Si ce n'est pas le cas,
	    TWCR = (1<<TWEN)|                   // Met à Jour le Registre TWCR 
     d6a:	85 ec       	ldi	r24, 0xC5	; 197
     d6c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
     d70:	1d c0       	rjmp	.+58     	; 0xdac <__vector_24+0xee>
	    (0<<TWWC);                          
    }
	else									     
    {
		// Si tout les bytes ont étés lus
	    TWCR = (1<<TWEN)|                          // Met à jour le TWCR
     d72:	85 e8       	ldi	r24, 0x85	; 133
     d74:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
     d78:	19 c0       	rjmp	.+50     	; 0xdac <__vector_24+0xee>
	    (0<<TWWC);                                 //
    }
    break;
	
    case TWI_RD_DATA_NACK:								// Le dernier byte à été reçu (nack envoyé)
		TWI_BufferTxRx[MsgPtr] = TWDR;					// Sauve les données
     d7a:	e0 91 66 02 	lds	r30, 0x0266	; 0x800266 <MsgPtr.1690>
     d7e:	f0 e0       	ldi	r31, 0x00	; 0
     d80:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
     d84:	e7 59       	subi	r30, 0x97	; 151
     d86:	fd 4f       	sbci	r31, 0xFD	; 253
     d88:	80 83       	st	Z, r24
		TWI_StatusTxRx.S_StatusBit.TransmitOk = 0x01;	// Flag de communication terminée correctement
     d8a:	80 91 67 02 	lds	r24, 0x0267	; 0x800267 <TWI_StatusTxRx>
     d8e:	81 60       	ori	r24, 0x01	; 1
     d90:	80 93 67 02 	sts	0x0267, r24	; 0x800267 <TWI_StatusTxRx>
		 
		TWCR = (1<<TWEN)|                          // Met à jour le registre de configuration TWI
     d94:	84 e9       	ldi	r24, 0x94	; 148
     d96:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
		(0<<TWIE)|(1<<TWINT)|                      // Désactive les interruptions et clear le Flag 
		(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Envoie la condition de stop 
		(0<<TWWC);                                 //
    break;
     d9a:	08 c0       	rjmp	.+16     	; 0xdac <__vector_24+0xee>
    case TWI_RD_ADR_NACK:		// Envoi de l'adresse + R, mais slave réponds avec NACK
    case TWI_WR_DATA_NACK:		// Envoi d'un byte, mais slave réponds avec NACK 
    case TWI_ERROR_BUS:			// Error sur le bus (Condition illegale (ex: Start-Stop)
    default:
		//TWI_state = TWSR;				// Sauve le registre de status et
		TWI_StatusTxRx.S_StatusBit.TransmitOk = 0x00;	// Efface le FLag de validation
     d9c:	80 91 67 02 	lds	r24, 0x0267	; 0x800267 <TWI_StatusTxRx>
     da0:	8e 7f       	andi	r24, 0xFE	; 254
     da2:	80 93 67 02 	sts	0x0267, r24	; 0x800267 <TWI_StatusTxRx>
    
		// Reset TWI Interface
		TWCR = (1<<TWEN)|					// Mise à jour du registre de CONF
     da6:	84 e0       	ldi	r24, 0x04	; 4
     da8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
		(0<<TWIE)|(0<<TWINT)|				// Désactive les interruptions
		(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|	// Stoppe la communication en cours
		(0<<TWWC);							//		
	}
}
     dac:	ff 91       	pop	r31
     dae:	ef 91       	pop	r30
     db0:	9f 91       	pop	r25
     db2:	8f 91       	pop	r24
     db4:	3f 91       	pop	r19
     db6:	2f 91       	pop	r18
     db8:	0f 90       	pop	r0
     dba:	0f be       	out	0x3f, r0	; 63
     dbc:	0f 90       	pop	r0
     dbe:	1f 90       	pop	r1
     dc0:	18 95       	reti

00000dc2 <__fixunssfsi>:
     dc2:	0e 94 55 07 	call	0xeaa	; 0xeaa <__fp_splitA>
     dc6:	88 f0       	brcs	.+34     	; 0xdea <__fixunssfsi+0x28>
     dc8:	9f 57       	subi	r25, 0x7F	; 127
     dca:	98 f0       	brcs	.+38     	; 0xdf2 <__fixunssfsi+0x30>
     dcc:	b9 2f       	mov	r27, r25
     dce:	99 27       	eor	r25, r25
     dd0:	b7 51       	subi	r27, 0x17	; 23
     dd2:	b0 f0       	brcs	.+44     	; 0xe00 <__fixunssfsi+0x3e>
     dd4:	e1 f0       	breq	.+56     	; 0xe0e <__fixunssfsi+0x4c>
     dd6:	66 0f       	add	r22, r22
     dd8:	77 1f       	adc	r23, r23
     dda:	88 1f       	adc	r24, r24
     ddc:	99 1f       	adc	r25, r25
     dde:	1a f0       	brmi	.+6      	; 0xde6 <__fixunssfsi+0x24>
     de0:	ba 95       	dec	r27
     de2:	c9 f7       	brne	.-14     	; 0xdd6 <__fixunssfsi+0x14>
     de4:	14 c0       	rjmp	.+40     	; 0xe0e <__fixunssfsi+0x4c>
     de6:	b1 30       	cpi	r27, 0x01	; 1
     de8:	91 f0       	breq	.+36     	; 0xe0e <__fixunssfsi+0x4c>
     dea:	0e 94 6f 07 	call	0xede	; 0xede <__fp_zero>
     dee:	b1 e0       	ldi	r27, 0x01	; 1
     df0:	08 95       	ret
     df2:	0c 94 6f 07 	jmp	0xede	; 0xede <__fp_zero>
     df6:	67 2f       	mov	r22, r23
     df8:	78 2f       	mov	r23, r24
     dfa:	88 27       	eor	r24, r24
     dfc:	b8 5f       	subi	r27, 0xF8	; 248
     dfe:	39 f0       	breq	.+14     	; 0xe0e <__fixunssfsi+0x4c>
     e00:	b9 3f       	cpi	r27, 0xF9	; 249
     e02:	cc f3       	brlt	.-14     	; 0xdf6 <__fixunssfsi+0x34>
     e04:	86 95       	lsr	r24
     e06:	77 95       	ror	r23
     e08:	67 95       	ror	r22
     e0a:	b3 95       	inc	r27
     e0c:	d9 f7       	brne	.-10     	; 0xe04 <__fixunssfsi+0x42>
     e0e:	3e f4       	brtc	.+14     	; 0xe1e <__fixunssfsi+0x5c>
     e10:	90 95       	com	r25
     e12:	80 95       	com	r24
     e14:	70 95       	com	r23
     e16:	61 95       	neg	r22
     e18:	7f 4f       	sbci	r23, 0xFF	; 255
     e1a:	8f 4f       	sbci	r24, 0xFF	; 255
     e1c:	9f 4f       	sbci	r25, 0xFF	; 255
     e1e:	08 95       	ret

00000e20 <__floatunsisf>:
     e20:	e8 94       	clt
     e22:	09 c0       	rjmp	.+18     	; 0xe36 <__floatsisf+0x12>

00000e24 <__floatsisf>:
     e24:	97 fb       	bst	r25, 7
     e26:	3e f4       	brtc	.+14     	; 0xe36 <__floatsisf+0x12>
     e28:	90 95       	com	r25
     e2a:	80 95       	com	r24
     e2c:	70 95       	com	r23
     e2e:	61 95       	neg	r22
     e30:	7f 4f       	sbci	r23, 0xFF	; 255
     e32:	8f 4f       	sbci	r24, 0xFF	; 255
     e34:	9f 4f       	sbci	r25, 0xFF	; 255
     e36:	99 23       	and	r25, r25
     e38:	a9 f0       	breq	.+42     	; 0xe64 <__floatsisf+0x40>
     e3a:	f9 2f       	mov	r31, r25
     e3c:	96 e9       	ldi	r25, 0x96	; 150
     e3e:	bb 27       	eor	r27, r27
     e40:	93 95       	inc	r25
     e42:	f6 95       	lsr	r31
     e44:	87 95       	ror	r24
     e46:	77 95       	ror	r23
     e48:	67 95       	ror	r22
     e4a:	b7 95       	ror	r27
     e4c:	f1 11       	cpse	r31, r1
     e4e:	f8 cf       	rjmp	.-16     	; 0xe40 <__floatsisf+0x1c>
     e50:	fa f4       	brpl	.+62     	; 0xe90 <__floatsisf+0x6c>
     e52:	bb 0f       	add	r27, r27
     e54:	11 f4       	brne	.+4      	; 0xe5a <__floatsisf+0x36>
     e56:	60 ff       	sbrs	r22, 0
     e58:	1b c0       	rjmp	.+54     	; 0xe90 <__floatsisf+0x6c>
     e5a:	6f 5f       	subi	r22, 0xFF	; 255
     e5c:	7f 4f       	sbci	r23, 0xFF	; 255
     e5e:	8f 4f       	sbci	r24, 0xFF	; 255
     e60:	9f 4f       	sbci	r25, 0xFF	; 255
     e62:	16 c0       	rjmp	.+44     	; 0xe90 <__floatsisf+0x6c>
     e64:	88 23       	and	r24, r24
     e66:	11 f0       	breq	.+4      	; 0xe6c <__floatsisf+0x48>
     e68:	96 e9       	ldi	r25, 0x96	; 150
     e6a:	11 c0       	rjmp	.+34     	; 0xe8e <__floatsisf+0x6a>
     e6c:	77 23       	and	r23, r23
     e6e:	21 f0       	breq	.+8      	; 0xe78 <__floatsisf+0x54>
     e70:	9e e8       	ldi	r25, 0x8E	; 142
     e72:	87 2f       	mov	r24, r23
     e74:	76 2f       	mov	r23, r22
     e76:	05 c0       	rjmp	.+10     	; 0xe82 <__floatsisf+0x5e>
     e78:	66 23       	and	r22, r22
     e7a:	71 f0       	breq	.+28     	; 0xe98 <__floatsisf+0x74>
     e7c:	96 e8       	ldi	r25, 0x86	; 134
     e7e:	86 2f       	mov	r24, r22
     e80:	70 e0       	ldi	r23, 0x00	; 0
     e82:	60 e0       	ldi	r22, 0x00	; 0
     e84:	2a f0       	brmi	.+10     	; 0xe90 <__floatsisf+0x6c>
     e86:	9a 95       	dec	r25
     e88:	66 0f       	add	r22, r22
     e8a:	77 1f       	adc	r23, r23
     e8c:	88 1f       	adc	r24, r24
     e8e:	da f7       	brpl	.-10     	; 0xe86 <__floatsisf+0x62>
     e90:	88 0f       	add	r24, r24
     e92:	96 95       	lsr	r25
     e94:	87 95       	ror	r24
     e96:	97 f9       	bld	r25, 7
     e98:	08 95       	ret

00000e9a <__fp_split3>:
     e9a:	57 fd       	sbrc	r21, 7
     e9c:	90 58       	subi	r25, 0x80	; 128
     e9e:	44 0f       	add	r20, r20
     ea0:	55 1f       	adc	r21, r21
     ea2:	59 f0       	breq	.+22     	; 0xeba <__fp_splitA+0x10>
     ea4:	5f 3f       	cpi	r21, 0xFF	; 255
     ea6:	71 f0       	breq	.+28     	; 0xec4 <__fp_splitA+0x1a>
     ea8:	47 95       	ror	r20

00000eaa <__fp_splitA>:
     eaa:	88 0f       	add	r24, r24
     eac:	97 fb       	bst	r25, 7
     eae:	99 1f       	adc	r25, r25
     eb0:	61 f0       	breq	.+24     	; 0xeca <__fp_splitA+0x20>
     eb2:	9f 3f       	cpi	r25, 0xFF	; 255
     eb4:	79 f0       	breq	.+30     	; 0xed4 <__fp_splitA+0x2a>
     eb6:	87 95       	ror	r24
     eb8:	08 95       	ret
     eba:	12 16       	cp	r1, r18
     ebc:	13 06       	cpc	r1, r19
     ebe:	14 06       	cpc	r1, r20
     ec0:	55 1f       	adc	r21, r21
     ec2:	f2 cf       	rjmp	.-28     	; 0xea8 <__fp_split3+0xe>
     ec4:	46 95       	lsr	r20
     ec6:	f1 df       	rcall	.-30     	; 0xeaa <__fp_splitA>
     ec8:	08 c0       	rjmp	.+16     	; 0xeda <__fp_splitA+0x30>
     eca:	16 16       	cp	r1, r22
     ecc:	17 06       	cpc	r1, r23
     ece:	18 06       	cpc	r1, r24
     ed0:	99 1f       	adc	r25, r25
     ed2:	f1 cf       	rjmp	.-30     	; 0xeb6 <__fp_splitA+0xc>
     ed4:	86 95       	lsr	r24
     ed6:	71 05       	cpc	r23, r1
     ed8:	61 05       	cpc	r22, r1
     eda:	08 94       	sec
     edc:	08 95       	ret

00000ede <__fp_zero>:
     ede:	e8 94       	clt

00000ee0 <__fp_szero>:
     ee0:	bb 27       	eor	r27, r27
     ee2:	66 27       	eor	r22, r22
     ee4:	77 27       	eor	r23, r23
     ee6:	cb 01       	movw	r24, r22
     ee8:	97 f9       	bld	r25, 7
     eea:	08 95       	ret

00000eec <__mulsf3>:
     eec:	0e 94 89 07 	call	0xf12	; 0xf12 <__mulsf3x>
     ef0:	0c 94 fa 07 	jmp	0xff4	; 0xff4 <__fp_round>
     ef4:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <__fp_pscA>
     ef8:	38 f0       	brcs	.+14     	; 0xf08 <__mulsf3+0x1c>
     efa:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <__fp_pscB>
     efe:	20 f0       	brcs	.+8      	; 0xf08 <__mulsf3+0x1c>
     f00:	95 23       	and	r25, r21
     f02:	11 f0       	breq	.+4      	; 0xf08 <__mulsf3+0x1c>
     f04:	0c 94 e3 07 	jmp	0xfc6	; 0xfc6 <__fp_inf>
     f08:	0c 94 e9 07 	jmp	0xfd2	; 0xfd2 <__fp_nan>
     f0c:	11 24       	eor	r1, r1
     f0e:	0c 94 70 07 	jmp	0xee0	; 0xee0 <__fp_szero>

00000f12 <__mulsf3x>:
     f12:	0e 94 4d 07 	call	0xe9a	; 0xe9a <__fp_split3>
     f16:	70 f3       	brcs	.-36     	; 0xef4 <__mulsf3+0x8>

00000f18 <__mulsf3_pse>:
     f18:	95 9f       	mul	r25, r21
     f1a:	c1 f3       	breq	.-16     	; 0xf0c <__mulsf3+0x20>
     f1c:	95 0f       	add	r25, r21
     f1e:	50 e0       	ldi	r21, 0x00	; 0
     f20:	55 1f       	adc	r21, r21
     f22:	62 9f       	mul	r22, r18
     f24:	f0 01       	movw	r30, r0
     f26:	72 9f       	mul	r23, r18
     f28:	bb 27       	eor	r27, r27
     f2a:	f0 0d       	add	r31, r0
     f2c:	b1 1d       	adc	r27, r1
     f2e:	63 9f       	mul	r22, r19
     f30:	aa 27       	eor	r26, r26
     f32:	f0 0d       	add	r31, r0
     f34:	b1 1d       	adc	r27, r1
     f36:	aa 1f       	adc	r26, r26
     f38:	64 9f       	mul	r22, r20
     f3a:	66 27       	eor	r22, r22
     f3c:	b0 0d       	add	r27, r0
     f3e:	a1 1d       	adc	r26, r1
     f40:	66 1f       	adc	r22, r22
     f42:	82 9f       	mul	r24, r18
     f44:	22 27       	eor	r18, r18
     f46:	b0 0d       	add	r27, r0
     f48:	a1 1d       	adc	r26, r1
     f4a:	62 1f       	adc	r22, r18
     f4c:	73 9f       	mul	r23, r19
     f4e:	b0 0d       	add	r27, r0
     f50:	a1 1d       	adc	r26, r1
     f52:	62 1f       	adc	r22, r18
     f54:	83 9f       	mul	r24, r19
     f56:	a0 0d       	add	r26, r0
     f58:	61 1d       	adc	r22, r1
     f5a:	22 1f       	adc	r18, r18
     f5c:	74 9f       	mul	r23, r20
     f5e:	33 27       	eor	r19, r19
     f60:	a0 0d       	add	r26, r0
     f62:	61 1d       	adc	r22, r1
     f64:	23 1f       	adc	r18, r19
     f66:	84 9f       	mul	r24, r20
     f68:	60 0d       	add	r22, r0
     f6a:	21 1d       	adc	r18, r1
     f6c:	82 2f       	mov	r24, r18
     f6e:	76 2f       	mov	r23, r22
     f70:	6a 2f       	mov	r22, r26
     f72:	11 24       	eor	r1, r1
     f74:	9f 57       	subi	r25, 0x7F	; 127
     f76:	50 40       	sbci	r21, 0x00	; 0
     f78:	9a f0       	brmi	.+38     	; 0xfa0 <__mulsf3_pse+0x88>
     f7a:	f1 f0       	breq	.+60     	; 0xfb8 <__mulsf3_pse+0xa0>
     f7c:	88 23       	and	r24, r24
     f7e:	4a f0       	brmi	.+18     	; 0xf92 <__mulsf3_pse+0x7a>
     f80:	ee 0f       	add	r30, r30
     f82:	ff 1f       	adc	r31, r31
     f84:	bb 1f       	adc	r27, r27
     f86:	66 1f       	adc	r22, r22
     f88:	77 1f       	adc	r23, r23
     f8a:	88 1f       	adc	r24, r24
     f8c:	91 50       	subi	r25, 0x01	; 1
     f8e:	50 40       	sbci	r21, 0x00	; 0
     f90:	a9 f7       	brne	.-22     	; 0xf7c <__mulsf3_pse+0x64>
     f92:	9e 3f       	cpi	r25, 0xFE	; 254
     f94:	51 05       	cpc	r21, r1
     f96:	80 f0       	brcs	.+32     	; 0xfb8 <__mulsf3_pse+0xa0>
     f98:	0c 94 e3 07 	jmp	0xfc6	; 0xfc6 <__fp_inf>
     f9c:	0c 94 70 07 	jmp	0xee0	; 0xee0 <__fp_szero>
     fa0:	5f 3f       	cpi	r21, 0xFF	; 255
     fa2:	e4 f3       	brlt	.-8      	; 0xf9c <__mulsf3_pse+0x84>
     fa4:	98 3e       	cpi	r25, 0xE8	; 232
     fa6:	d4 f3       	brlt	.-12     	; 0xf9c <__mulsf3_pse+0x84>
     fa8:	86 95       	lsr	r24
     faa:	77 95       	ror	r23
     fac:	67 95       	ror	r22
     fae:	b7 95       	ror	r27
     fb0:	f7 95       	ror	r31
     fb2:	e7 95       	ror	r30
     fb4:	9f 5f       	subi	r25, 0xFF	; 255
     fb6:	c1 f7       	brne	.-16     	; 0xfa8 <__mulsf3_pse+0x90>
     fb8:	fe 2b       	or	r31, r30
     fba:	88 0f       	add	r24, r24
     fbc:	91 1d       	adc	r25, r1
     fbe:	96 95       	lsr	r25
     fc0:	87 95       	ror	r24
     fc2:	97 f9       	bld	r25, 7
     fc4:	08 95       	ret

00000fc6 <__fp_inf>:
     fc6:	97 f9       	bld	r25, 7
     fc8:	9f 67       	ori	r25, 0x7F	; 127
     fca:	80 e8       	ldi	r24, 0x80	; 128
     fcc:	70 e0       	ldi	r23, 0x00	; 0
     fce:	60 e0       	ldi	r22, 0x00	; 0
     fd0:	08 95       	ret

00000fd2 <__fp_nan>:
     fd2:	9f ef       	ldi	r25, 0xFF	; 255
     fd4:	80 ec       	ldi	r24, 0xC0	; 192
     fd6:	08 95       	ret

00000fd8 <__fp_pscA>:
     fd8:	00 24       	eor	r0, r0
     fda:	0a 94       	dec	r0
     fdc:	16 16       	cp	r1, r22
     fde:	17 06       	cpc	r1, r23
     fe0:	18 06       	cpc	r1, r24
     fe2:	09 06       	cpc	r0, r25
     fe4:	08 95       	ret

00000fe6 <__fp_pscB>:
     fe6:	00 24       	eor	r0, r0
     fe8:	0a 94       	dec	r0
     fea:	12 16       	cp	r1, r18
     fec:	13 06       	cpc	r1, r19
     fee:	14 06       	cpc	r1, r20
     ff0:	05 06       	cpc	r0, r21
     ff2:	08 95       	ret

00000ff4 <__fp_round>:
     ff4:	09 2e       	mov	r0, r25
     ff6:	03 94       	inc	r0
     ff8:	00 0c       	add	r0, r0
     ffa:	11 f4       	brne	.+4      	; 0x1000 <__fp_round+0xc>
     ffc:	88 23       	and	r24, r24
     ffe:	52 f0       	brmi	.+20     	; 0x1014 <__fp_round+0x20>
    1000:	bb 0f       	add	r27, r27
    1002:	40 f4       	brcc	.+16     	; 0x1014 <__fp_round+0x20>
    1004:	bf 2b       	or	r27, r31
    1006:	11 f4       	brne	.+4      	; 0x100c <__fp_round+0x18>
    1008:	60 ff       	sbrs	r22, 0
    100a:	04 c0       	rjmp	.+8      	; 0x1014 <__fp_round+0x20>
    100c:	6f 5f       	subi	r22, 0xFF	; 255
    100e:	7f 4f       	sbci	r23, 0xFF	; 255
    1010:	8f 4f       	sbci	r24, 0xFF	; 255
    1012:	9f 4f       	sbci	r25, 0xFF	; 255
    1014:	08 95       	ret

00001016 <__divmodhi4>:
    1016:	97 fb       	bst	r25, 7
    1018:	07 2e       	mov	r0, r23
    101a:	16 f4       	brtc	.+4      	; 0x1020 <__divmodhi4+0xa>
    101c:	00 94       	com	r0
    101e:	07 d0       	rcall	.+14     	; 0x102e <__divmodhi4_neg1>
    1020:	77 fd       	sbrc	r23, 7
    1022:	09 d0       	rcall	.+18     	; 0x1036 <__divmodhi4_neg2>
    1024:	0e 94 1f 08 	call	0x103e	; 0x103e <__udivmodhi4>
    1028:	07 fc       	sbrc	r0, 7
    102a:	05 d0       	rcall	.+10     	; 0x1036 <__divmodhi4_neg2>
    102c:	3e f4       	brtc	.+14     	; 0x103c <__divmodhi4_exit>

0000102e <__divmodhi4_neg1>:
    102e:	90 95       	com	r25
    1030:	81 95       	neg	r24
    1032:	9f 4f       	sbci	r25, 0xFF	; 255
    1034:	08 95       	ret

00001036 <__divmodhi4_neg2>:
    1036:	70 95       	com	r23
    1038:	61 95       	neg	r22
    103a:	7f 4f       	sbci	r23, 0xFF	; 255

0000103c <__divmodhi4_exit>:
    103c:	08 95       	ret

0000103e <__udivmodhi4>:
    103e:	aa 1b       	sub	r26, r26
    1040:	bb 1b       	sub	r27, r27
    1042:	51 e1       	ldi	r21, 0x11	; 17
    1044:	07 c0       	rjmp	.+14     	; 0x1054 <__udivmodhi4_ep>

00001046 <__udivmodhi4_loop>:
    1046:	aa 1f       	adc	r26, r26
    1048:	bb 1f       	adc	r27, r27
    104a:	a6 17       	cp	r26, r22
    104c:	b7 07       	cpc	r27, r23
    104e:	10 f0       	brcs	.+4      	; 0x1054 <__udivmodhi4_ep>
    1050:	a6 1b       	sub	r26, r22
    1052:	b7 0b       	sbc	r27, r23

00001054 <__udivmodhi4_ep>:
    1054:	88 1f       	adc	r24, r24
    1056:	99 1f       	adc	r25, r25
    1058:	5a 95       	dec	r21
    105a:	a9 f7       	brne	.-22     	; 0x1046 <__udivmodhi4_loop>
    105c:	80 95       	com	r24
    105e:	90 95       	com	r25
    1060:	bc 01       	movw	r22, r24
    1062:	cd 01       	movw	r24, r26
    1064:	08 95       	ret

00001066 <do_rand>:
    1066:	8f 92       	push	r8
    1068:	9f 92       	push	r9
    106a:	af 92       	push	r10
    106c:	bf 92       	push	r11
    106e:	cf 92       	push	r12
    1070:	df 92       	push	r13
    1072:	ef 92       	push	r14
    1074:	ff 92       	push	r15
    1076:	cf 93       	push	r28
    1078:	df 93       	push	r29
    107a:	ec 01       	movw	r28, r24
    107c:	68 81       	ld	r22, Y
    107e:	79 81       	ldd	r23, Y+1	; 0x01
    1080:	8a 81       	ldd	r24, Y+2	; 0x02
    1082:	9b 81       	ldd	r25, Y+3	; 0x03
    1084:	61 15       	cp	r22, r1
    1086:	71 05       	cpc	r23, r1
    1088:	81 05       	cpc	r24, r1
    108a:	91 05       	cpc	r25, r1
    108c:	21 f4       	brne	.+8      	; 0x1096 <do_rand+0x30>
    108e:	64 e2       	ldi	r22, 0x24	; 36
    1090:	79 ed       	ldi	r23, 0xD9	; 217
    1092:	8b e5       	ldi	r24, 0x5B	; 91
    1094:	97 e0       	ldi	r25, 0x07	; 7
    1096:	2d e1       	ldi	r18, 0x1D	; 29
    1098:	33 ef       	ldi	r19, 0xF3	; 243
    109a:	41 e0       	ldi	r20, 0x01	; 1
    109c:	50 e0       	ldi	r21, 0x00	; 0
    109e:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <__divmodsi4>
    10a2:	49 01       	movw	r8, r18
    10a4:	5a 01       	movw	r10, r20
    10a6:	9b 01       	movw	r18, r22
    10a8:	ac 01       	movw	r20, r24
    10aa:	a7 ea       	ldi	r26, 0xA7	; 167
    10ac:	b1 e4       	ldi	r27, 0x41	; 65
    10ae:	0e 94 77 0b 	call	0x16ee	; 0x16ee <__muluhisi3>
    10b2:	6b 01       	movw	r12, r22
    10b4:	7c 01       	movw	r14, r24
    10b6:	ac ee       	ldi	r26, 0xEC	; 236
    10b8:	b4 ef       	ldi	r27, 0xF4	; 244
    10ba:	a5 01       	movw	r20, r10
    10bc:	94 01       	movw	r18, r8
    10be:	0e 94 85 0b 	call	0x170a	; 0x170a <__mulohisi3>
    10c2:	dc 01       	movw	r26, r24
    10c4:	cb 01       	movw	r24, r22
    10c6:	8c 0d       	add	r24, r12
    10c8:	9d 1d       	adc	r25, r13
    10ca:	ae 1d       	adc	r26, r14
    10cc:	bf 1d       	adc	r27, r15
    10ce:	b7 ff       	sbrs	r27, 7
    10d0:	03 c0       	rjmp	.+6      	; 0x10d8 <do_rand+0x72>
    10d2:	01 97       	sbiw	r24, 0x01	; 1
    10d4:	a1 09       	sbc	r26, r1
    10d6:	b0 48       	sbci	r27, 0x80	; 128
    10d8:	88 83       	st	Y, r24
    10da:	99 83       	std	Y+1, r25	; 0x01
    10dc:	aa 83       	std	Y+2, r26	; 0x02
    10de:	bb 83       	std	Y+3, r27	; 0x03
    10e0:	9f 77       	andi	r25, 0x7F	; 127
    10e2:	df 91       	pop	r29
    10e4:	cf 91       	pop	r28
    10e6:	ff 90       	pop	r15
    10e8:	ef 90       	pop	r14
    10ea:	df 90       	pop	r13
    10ec:	cf 90       	pop	r12
    10ee:	bf 90       	pop	r11
    10f0:	af 90       	pop	r10
    10f2:	9f 90       	pop	r9
    10f4:	8f 90       	pop	r8
    10f6:	08 95       	ret

000010f8 <rand_r>:
    10f8:	0e 94 33 08 	call	0x1066	; 0x1066 <do_rand>
    10fc:	08 95       	ret

000010fe <rand>:
    10fe:	80 e0       	ldi	r24, 0x00	; 0
    1100:	91 e0       	ldi	r25, 0x01	; 1
    1102:	0e 94 33 08 	call	0x1066	; 0x1066 <do_rand>
    1106:	08 95       	ret

00001108 <srand>:
    1108:	a0 e0       	ldi	r26, 0x00	; 0
    110a:	b0 e0       	ldi	r27, 0x00	; 0
    110c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    1110:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
    1114:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
    1118:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
    111c:	08 95       	ret

0000111e <sprintf>:
    111e:	ae e0       	ldi	r26, 0x0E	; 14
    1120:	b0 e0       	ldi	r27, 0x00	; 0
    1122:	e5 e9       	ldi	r30, 0x95	; 149
    1124:	f8 e0       	ldi	r31, 0x08	; 8
    1126:	0c 94 98 0b 	jmp	0x1730	; 0x1730 <__prologue_saves__+0x1c>
    112a:	0d 89       	ldd	r16, Y+21	; 0x15
    112c:	1e 89       	ldd	r17, Y+22	; 0x16
    112e:	86 e0       	ldi	r24, 0x06	; 6
    1130:	8c 83       	std	Y+4, r24	; 0x04
    1132:	1a 83       	std	Y+2, r17	; 0x02
    1134:	09 83       	std	Y+1, r16	; 0x01
    1136:	8f ef       	ldi	r24, 0xFF	; 255
    1138:	9f e7       	ldi	r25, 0x7F	; 127
    113a:	9e 83       	std	Y+6, r25	; 0x06
    113c:	8d 83       	std	Y+5, r24	; 0x05
    113e:	ae 01       	movw	r20, r28
    1140:	47 5e       	subi	r20, 0xE7	; 231
    1142:	5f 4f       	sbci	r21, 0xFF	; 255
    1144:	6f 89       	ldd	r22, Y+23	; 0x17
    1146:	78 8d       	ldd	r23, Y+24	; 0x18
    1148:	ce 01       	movw	r24, r28
    114a:	01 96       	adiw	r24, 0x01	; 1
    114c:	0e 94 b1 08 	call	0x1162	; 0x1162 <vfprintf>
    1150:	ef 81       	ldd	r30, Y+7	; 0x07
    1152:	f8 85       	ldd	r31, Y+8	; 0x08
    1154:	e0 0f       	add	r30, r16
    1156:	f1 1f       	adc	r31, r17
    1158:	10 82       	st	Z, r1
    115a:	2e 96       	adiw	r28, 0x0e	; 14
    115c:	e4 e0       	ldi	r30, 0x04	; 4
    115e:	0c 94 b4 0b 	jmp	0x1768	; 0x1768 <__epilogue_restores__+0x1c>

00001162 <vfprintf>:
    1162:	ab e0       	ldi	r26, 0x0B	; 11
    1164:	b0 e0       	ldi	r27, 0x00	; 0
    1166:	e7 eb       	ldi	r30, 0xB7	; 183
    1168:	f8 e0       	ldi	r31, 0x08	; 8
    116a:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__prologue_saves__>
    116e:	6c 01       	movw	r12, r24
    1170:	7b 01       	movw	r14, r22
    1172:	8a 01       	movw	r16, r20
    1174:	fc 01       	movw	r30, r24
    1176:	17 82       	std	Z+7, r1	; 0x07
    1178:	16 82       	std	Z+6, r1	; 0x06
    117a:	83 81       	ldd	r24, Z+3	; 0x03
    117c:	81 ff       	sbrs	r24, 1
    117e:	cc c1       	rjmp	.+920    	; 0x1518 <vfprintf+0x3b6>
    1180:	ce 01       	movw	r24, r28
    1182:	01 96       	adiw	r24, 0x01	; 1
    1184:	3c 01       	movw	r6, r24
    1186:	f6 01       	movw	r30, r12
    1188:	93 81       	ldd	r25, Z+3	; 0x03
    118a:	f7 01       	movw	r30, r14
    118c:	93 fd       	sbrc	r25, 3
    118e:	85 91       	lpm	r24, Z+
    1190:	93 ff       	sbrs	r25, 3
    1192:	81 91       	ld	r24, Z+
    1194:	7f 01       	movw	r14, r30
    1196:	88 23       	and	r24, r24
    1198:	09 f4       	brne	.+2      	; 0x119c <vfprintf+0x3a>
    119a:	ba c1       	rjmp	.+884    	; 0x1510 <vfprintf+0x3ae>
    119c:	85 32       	cpi	r24, 0x25	; 37
    119e:	39 f4       	brne	.+14     	; 0x11ae <vfprintf+0x4c>
    11a0:	93 fd       	sbrc	r25, 3
    11a2:	85 91       	lpm	r24, Z+
    11a4:	93 ff       	sbrs	r25, 3
    11a6:	81 91       	ld	r24, Z+
    11a8:	7f 01       	movw	r14, r30
    11aa:	85 32       	cpi	r24, 0x25	; 37
    11ac:	29 f4       	brne	.+10     	; 0x11b8 <vfprintf+0x56>
    11ae:	b6 01       	movw	r22, r12
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	0e 94 a8 0a 	call	0x1550	; 0x1550 <fputc>
    11b6:	e7 cf       	rjmp	.-50     	; 0x1186 <vfprintf+0x24>
    11b8:	91 2c       	mov	r9, r1
    11ba:	21 2c       	mov	r2, r1
    11bc:	31 2c       	mov	r3, r1
    11be:	ff e1       	ldi	r31, 0x1F	; 31
    11c0:	f3 15       	cp	r31, r3
    11c2:	d8 f0       	brcs	.+54     	; 0x11fa <vfprintf+0x98>
    11c4:	8b 32       	cpi	r24, 0x2B	; 43
    11c6:	79 f0       	breq	.+30     	; 0x11e6 <vfprintf+0x84>
    11c8:	38 f4       	brcc	.+14     	; 0x11d8 <vfprintf+0x76>
    11ca:	80 32       	cpi	r24, 0x20	; 32
    11cc:	79 f0       	breq	.+30     	; 0x11ec <vfprintf+0x8a>
    11ce:	83 32       	cpi	r24, 0x23	; 35
    11d0:	a1 f4       	brne	.+40     	; 0x11fa <vfprintf+0x98>
    11d2:	23 2d       	mov	r18, r3
    11d4:	20 61       	ori	r18, 0x10	; 16
    11d6:	1d c0       	rjmp	.+58     	; 0x1212 <vfprintf+0xb0>
    11d8:	8d 32       	cpi	r24, 0x2D	; 45
    11da:	61 f0       	breq	.+24     	; 0x11f4 <vfprintf+0x92>
    11dc:	80 33       	cpi	r24, 0x30	; 48
    11de:	69 f4       	brne	.+26     	; 0x11fa <vfprintf+0x98>
    11e0:	23 2d       	mov	r18, r3
    11e2:	21 60       	ori	r18, 0x01	; 1
    11e4:	16 c0       	rjmp	.+44     	; 0x1212 <vfprintf+0xb0>
    11e6:	83 2d       	mov	r24, r3
    11e8:	82 60       	ori	r24, 0x02	; 2
    11ea:	38 2e       	mov	r3, r24
    11ec:	e3 2d       	mov	r30, r3
    11ee:	e4 60       	ori	r30, 0x04	; 4
    11f0:	3e 2e       	mov	r3, r30
    11f2:	2a c0       	rjmp	.+84     	; 0x1248 <vfprintf+0xe6>
    11f4:	f3 2d       	mov	r31, r3
    11f6:	f8 60       	ori	r31, 0x08	; 8
    11f8:	1d c0       	rjmp	.+58     	; 0x1234 <vfprintf+0xd2>
    11fa:	37 fc       	sbrc	r3, 7
    11fc:	2d c0       	rjmp	.+90     	; 0x1258 <vfprintf+0xf6>
    11fe:	20 ed       	ldi	r18, 0xD0	; 208
    1200:	28 0f       	add	r18, r24
    1202:	2a 30       	cpi	r18, 0x0A	; 10
    1204:	40 f0       	brcs	.+16     	; 0x1216 <vfprintf+0xb4>
    1206:	8e 32       	cpi	r24, 0x2E	; 46
    1208:	b9 f4       	brne	.+46     	; 0x1238 <vfprintf+0xd6>
    120a:	36 fc       	sbrc	r3, 6
    120c:	81 c1       	rjmp	.+770    	; 0x1510 <vfprintf+0x3ae>
    120e:	23 2d       	mov	r18, r3
    1210:	20 64       	ori	r18, 0x40	; 64
    1212:	32 2e       	mov	r3, r18
    1214:	19 c0       	rjmp	.+50     	; 0x1248 <vfprintf+0xe6>
    1216:	36 fe       	sbrs	r3, 6
    1218:	06 c0       	rjmp	.+12     	; 0x1226 <vfprintf+0xc4>
    121a:	8a e0       	ldi	r24, 0x0A	; 10
    121c:	98 9e       	mul	r9, r24
    121e:	20 0d       	add	r18, r0
    1220:	11 24       	eor	r1, r1
    1222:	92 2e       	mov	r9, r18
    1224:	11 c0       	rjmp	.+34     	; 0x1248 <vfprintf+0xe6>
    1226:	ea e0       	ldi	r30, 0x0A	; 10
    1228:	2e 9e       	mul	r2, r30
    122a:	20 0d       	add	r18, r0
    122c:	11 24       	eor	r1, r1
    122e:	22 2e       	mov	r2, r18
    1230:	f3 2d       	mov	r31, r3
    1232:	f0 62       	ori	r31, 0x20	; 32
    1234:	3f 2e       	mov	r3, r31
    1236:	08 c0       	rjmp	.+16     	; 0x1248 <vfprintf+0xe6>
    1238:	8c 36       	cpi	r24, 0x6C	; 108
    123a:	21 f4       	brne	.+8      	; 0x1244 <vfprintf+0xe2>
    123c:	83 2d       	mov	r24, r3
    123e:	80 68       	ori	r24, 0x80	; 128
    1240:	38 2e       	mov	r3, r24
    1242:	02 c0       	rjmp	.+4      	; 0x1248 <vfprintf+0xe6>
    1244:	88 36       	cpi	r24, 0x68	; 104
    1246:	41 f4       	brne	.+16     	; 0x1258 <vfprintf+0xf6>
    1248:	f7 01       	movw	r30, r14
    124a:	93 fd       	sbrc	r25, 3
    124c:	85 91       	lpm	r24, Z+
    124e:	93 ff       	sbrs	r25, 3
    1250:	81 91       	ld	r24, Z+
    1252:	7f 01       	movw	r14, r30
    1254:	81 11       	cpse	r24, r1
    1256:	b3 cf       	rjmp	.-154    	; 0x11be <vfprintf+0x5c>
    1258:	98 2f       	mov	r25, r24
    125a:	9f 7d       	andi	r25, 0xDF	; 223
    125c:	95 54       	subi	r25, 0x45	; 69
    125e:	93 30       	cpi	r25, 0x03	; 3
    1260:	28 f4       	brcc	.+10     	; 0x126c <vfprintf+0x10a>
    1262:	0c 5f       	subi	r16, 0xFC	; 252
    1264:	1f 4f       	sbci	r17, 0xFF	; 255
    1266:	9f e3       	ldi	r25, 0x3F	; 63
    1268:	99 83       	std	Y+1, r25	; 0x01
    126a:	0d c0       	rjmp	.+26     	; 0x1286 <vfprintf+0x124>
    126c:	83 36       	cpi	r24, 0x63	; 99
    126e:	31 f0       	breq	.+12     	; 0x127c <vfprintf+0x11a>
    1270:	83 37       	cpi	r24, 0x73	; 115
    1272:	71 f0       	breq	.+28     	; 0x1290 <vfprintf+0x12e>
    1274:	83 35       	cpi	r24, 0x53	; 83
    1276:	09 f0       	breq	.+2      	; 0x127a <vfprintf+0x118>
    1278:	59 c0       	rjmp	.+178    	; 0x132c <vfprintf+0x1ca>
    127a:	21 c0       	rjmp	.+66     	; 0x12be <vfprintf+0x15c>
    127c:	f8 01       	movw	r30, r16
    127e:	80 81       	ld	r24, Z
    1280:	89 83       	std	Y+1, r24	; 0x01
    1282:	0e 5f       	subi	r16, 0xFE	; 254
    1284:	1f 4f       	sbci	r17, 0xFF	; 255
    1286:	88 24       	eor	r8, r8
    1288:	83 94       	inc	r8
    128a:	91 2c       	mov	r9, r1
    128c:	53 01       	movw	r10, r6
    128e:	13 c0       	rjmp	.+38     	; 0x12b6 <vfprintf+0x154>
    1290:	28 01       	movw	r4, r16
    1292:	f2 e0       	ldi	r31, 0x02	; 2
    1294:	4f 0e       	add	r4, r31
    1296:	51 1c       	adc	r5, r1
    1298:	f8 01       	movw	r30, r16
    129a:	a0 80       	ld	r10, Z
    129c:	b1 80       	ldd	r11, Z+1	; 0x01
    129e:	36 fe       	sbrs	r3, 6
    12a0:	03 c0       	rjmp	.+6      	; 0x12a8 <vfprintf+0x146>
    12a2:	69 2d       	mov	r22, r9
    12a4:	70 e0       	ldi	r23, 0x00	; 0
    12a6:	02 c0       	rjmp	.+4      	; 0x12ac <vfprintf+0x14a>
    12a8:	6f ef       	ldi	r22, 0xFF	; 255
    12aa:	7f ef       	ldi	r23, 0xFF	; 255
    12ac:	c5 01       	movw	r24, r10
    12ae:	0e 94 9d 0a 	call	0x153a	; 0x153a <strnlen>
    12b2:	4c 01       	movw	r8, r24
    12b4:	82 01       	movw	r16, r4
    12b6:	f3 2d       	mov	r31, r3
    12b8:	ff 77       	andi	r31, 0x7F	; 127
    12ba:	3f 2e       	mov	r3, r31
    12bc:	16 c0       	rjmp	.+44     	; 0x12ea <vfprintf+0x188>
    12be:	28 01       	movw	r4, r16
    12c0:	22 e0       	ldi	r18, 0x02	; 2
    12c2:	42 0e       	add	r4, r18
    12c4:	51 1c       	adc	r5, r1
    12c6:	f8 01       	movw	r30, r16
    12c8:	a0 80       	ld	r10, Z
    12ca:	b1 80       	ldd	r11, Z+1	; 0x01
    12cc:	36 fe       	sbrs	r3, 6
    12ce:	03 c0       	rjmp	.+6      	; 0x12d6 <vfprintf+0x174>
    12d0:	69 2d       	mov	r22, r9
    12d2:	70 e0       	ldi	r23, 0x00	; 0
    12d4:	02 c0       	rjmp	.+4      	; 0x12da <vfprintf+0x178>
    12d6:	6f ef       	ldi	r22, 0xFF	; 255
    12d8:	7f ef       	ldi	r23, 0xFF	; 255
    12da:	c5 01       	movw	r24, r10
    12dc:	0e 94 92 0a 	call	0x1524	; 0x1524 <strnlen_P>
    12e0:	4c 01       	movw	r8, r24
    12e2:	f3 2d       	mov	r31, r3
    12e4:	f0 68       	ori	r31, 0x80	; 128
    12e6:	3f 2e       	mov	r3, r31
    12e8:	82 01       	movw	r16, r4
    12ea:	33 fc       	sbrc	r3, 3
    12ec:	1b c0       	rjmp	.+54     	; 0x1324 <vfprintf+0x1c2>
    12ee:	82 2d       	mov	r24, r2
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	88 16       	cp	r8, r24
    12f4:	99 06       	cpc	r9, r25
    12f6:	b0 f4       	brcc	.+44     	; 0x1324 <vfprintf+0x1c2>
    12f8:	b6 01       	movw	r22, r12
    12fa:	80 e2       	ldi	r24, 0x20	; 32
    12fc:	90 e0       	ldi	r25, 0x00	; 0
    12fe:	0e 94 a8 0a 	call	0x1550	; 0x1550 <fputc>
    1302:	2a 94       	dec	r2
    1304:	f4 cf       	rjmp	.-24     	; 0x12ee <vfprintf+0x18c>
    1306:	f5 01       	movw	r30, r10
    1308:	37 fc       	sbrc	r3, 7
    130a:	85 91       	lpm	r24, Z+
    130c:	37 fe       	sbrs	r3, 7
    130e:	81 91       	ld	r24, Z+
    1310:	5f 01       	movw	r10, r30
    1312:	b6 01       	movw	r22, r12
    1314:	90 e0       	ldi	r25, 0x00	; 0
    1316:	0e 94 a8 0a 	call	0x1550	; 0x1550 <fputc>
    131a:	21 10       	cpse	r2, r1
    131c:	2a 94       	dec	r2
    131e:	21 e0       	ldi	r18, 0x01	; 1
    1320:	82 1a       	sub	r8, r18
    1322:	91 08       	sbc	r9, r1
    1324:	81 14       	cp	r8, r1
    1326:	91 04       	cpc	r9, r1
    1328:	71 f7       	brne	.-36     	; 0x1306 <vfprintf+0x1a4>
    132a:	e8 c0       	rjmp	.+464    	; 0x14fc <vfprintf+0x39a>
    132c:	84 36       	cpi	r24, 0x64	; 100
    132e:	11 f0       	breq	.+4      	; 0x1334 <vfprintf+0x1d2>
    1330:	89 36       	cpi	r24, 0x69	; 105
    1332:	41 f5       	brne	.+80     	; 0x1384 <vfprintf+0x222>
    1334:	f8 01       	movw	r30, r16
    1336:	37 fe       	sbrs	r3, 7
    1338:	07 c0       	rjmp	.+14     	; 0x1348 <vfprintf+0x1e6>
    133a:	60 81       	ld	r22, Z
    133c:	71 81       	ldd	r23, Z+1	; 0x01
    133e:	82 81       	ldd	r24, Z+2	; 0x02
    1340:	93 81       	ldd	r25, Z+3	; 0x03
    1342:	0c 5f       	subi	r16, 0xFC	; 252
    1344:	1f 4f       	sbci	r17, 0xFF	; 255
    1346:	08 c0       	rjmp	.+16     	; 0x1358 <vfprintf+0x1f6>
    1348:	60 81       	ld	r22, Z
    134a:	71 81       	ldd	r23, Z+1	; 0x01
    134c:	07 2e       	mov	r0, r23
    134e:	00 0c       	add	r0, r0
    1350:	88 0b       	sbc	r24, r24
    1352:	99 0b       	sbc	r25, r25
    1354:	0e 5f       	subi	r16, 0xFE	; 254
    1356:	1f 4f       	sbci	r17, 0xFF	; 255
    1358:	f3 2d       	mov	r31, r3
    135a:	ff 76       	andi	r31, 0x6F	; 111
    135c:	3f 2e       	mov	r3, r31
    135e:	97 ff       	sbrs	r25, 7
    1360:	09 c0       	rjmp	.+18     	; 0x1374 <vfprintf+0x212>
    1362:	90 95       	com	r25
    1364:	80 95       	com	r24
    1366:	70 95       	com	r23
    1368:	61 95       	neg	r22
    136a:	7f 4f       	sbci	r23, 0xFF	; 255
    136c:	8f 4f       	sbci	r24, 0xFF	; 255
    136e:	9f 4f       	sbci	r25, 0xFF	; 255
    1370:	f0 68       	ori	r31, 0x80	; 128
    1372:	3f 2e       	mov	r3, r31
    1374:	2a e0       	ldi	r18, 0x0A	; 10
    1376:	30 e0       	ldi	r19, 0x00	; 0
    1378:	a3 01       	movw	r20, r6
    137a:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <__ultoa_invert>
    137e:	88 2e       	mov	r8, r24
    1380:	86 18       	sub	r8, r6
    1382:	45 c0       	rjmp	.+138    	; 0x140e <vfprintf+0x2ac>
    1384:	85 37       	cpi	r24, 0x75	; 117
    1386:	31 f4       	brne	.+12     	; 0x1394 <vfprintf+0x232>
    1388:	23 2d       	mov	r18, r3
    138a:	2f 7e       	andi	r18, 0xEF	; 239
    138c:	b2 2e       	mov	r11, r18
    138e:	2a e0       	ldi	r18, 0x0A	; 10
    1390:	30 e0       	ldi	r19, 0x00	; 0
    1392:	25 c0       	rjmp	.+74     	; 0x13de <vfprintf+0x27c>
    1394:	93 2d       	mov	r25, r3
    1396:	99 7f       	andi	r25, 0xF9	; 249
    1398:	b9 2e       	mov	r11, r25
    139a:	8f 36       	cpi	r24, 0x6F	; 111
    139c:	c1 f0       	breq	.+48     	; 0x13ce <vfprintf+0x26c>
    139e:	18 f4       	brcc	.+6      	; 0x13a6 <vfprintf+0x244>
    13a0:	88 35       	cpi	r24, 0x58	; 88
    13a2:	79 f0       	breq	.+30     	; 0x13c2 <vfprintf+0x260>
    13a4:	b5 c0       	rjmp	.+362    	; 0x1510 <vfprintf+0x3ae>
    13a6:	80 37       	cpi	r24, 0x70	; 112
    13a8:	19 f0       	breq	.+6      	; 0x13b0 <vfprintf+0x24e>
    13aa:	88 37       	cpi	r24, 0x78	; 120
    13ac:	21 f0       	breq	.+8      	; 0x13b6 <vfprintf+0x254>
    13ae:	b0 c0       	rjmp	.+352    	; 0x1510 <vfprintf+0x3ae>
    13b0:	e9 2f       	mov	r30, r25
    13b2:	e0 61       	ori	r30, 0x10	; 16
    13b4:	be 2e       	mov	r11, r30
    13b6:	b4 fe       	sbrs	r11, 4
    13b8:	0d c0       	rjmp	.+26     	; 0x13d4 <vfprintf+0x272>
    13ba:	fb 2d       	mov	r31, r11
    13bc:	f4 60       	ori	r31, 0x04	; 4
    13be:	bf 2e       	mov	r11, r31
    13c0:	09 c0       	rjmp	.+18     	; 0x13d4 <vfprintf+0x272>
    13c2:	34 fe       	sbrs	r3, 4
    13c4:	0a c0       	rjmp	.+20     	; 0x13da <vfprintf+0x278>
    13c6:	29 2f       	mov	r18, r25
    13c8:	26 60       	ori	r18, 0x06	; 6
    13ca:	b2 2e       	mov	r11, r18
    13cc:	06 c0       	rjmp	.+12     	; 0x13da <vfprintf+0x278>
    13ce:	28 e0       	ldi	r18, 0x08	; 8
    13d0:	30 e0       	ldi	r19, 0x00	; 0
    13d2:	05 c0       	rjmp	.+10     	; 0x13de <vfprintf+0x27c>
    13d4:	20 e1       	ldi	r18, 0x10	; 16
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	02 c0       	rjmp	.+4      	; 0x13de <vfprintf+0x27c>
    13da:	20 e1       	ldi	r18, 0x10	; 16
    13dc:	32 e0       	ldi	r19, 0x02	; 2
    13de:	f8 01       	movw	r30, r16
    13e0:	b7 fe       	sbrs	r11, 7
    13e2:	07 c0       	rjmp	.+14     	; 0x13f2 <vfprintf+0x290>
    13e4:	60 81       	ld	r22, Z
    13e6:	71 81       	ldd	r23, Z+1	; 0x01
    13e8:	82 81       	ldd	r24, Z+2	; 0x02
    13ea:	93 81       	ldd	r25, Z+3	; 0x03
    13ec:	0c 5f       	subi	r16, 0xFC	; 252
    13ee:	1f 4f       	sbci	r17, 0xFF	; 255
    13f0:	06 c0       	rjmp	.+12     	; 0x13fe <vfprintf+0x29c>
    13f2:	60 81       	ld	r22, Z
    13f4:	71 81       	ldd	r23, Z+1	; 0x01
    13f6:	80 e0       	ldi	r24, 0x00	; 0
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	0e 5f       	subi	r16, 0xFE	; 254
    13fc:	1f 4f       	sbci	r17, 0xFF	; 255
    13fe:	a3 01       	movw	r20, r6
    1400:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <__ultoa_invert>
    1404:	88 2e       	mov	r8, r24
    1406:	86 18       	sub	r8, r6
    1408:	fb 2d       	mov	r31, r11
    140a:	ff 77       	andi	r31, 0x7F	; 127
    140c:	3f 2e       	mov	r3, r31
    140e:	36 fe       	sbrs	r3, 6
    1410:	0d c0       	rjmp	.+26     	; 0x142c <vfprintf+0x2ca>
    1412:	23 2d       	mov	r18, r3
    1414:	2e 7f       	andi	r18, 0xFE	; 254
    1416:	a2 2e       	mov	r10, r18
    1418:	89 14       	cp	r8, r9
    141a:	58 f4       	brcc	.+22     	; 0x1432 <vfprintf+0x2d0>
    141c:	34 fe       	sbrs	r3, 4
    141e:	0b c0       	rjmp	.+22     	; 0x1436 <vfprintf+0x2d4>
    1420:	32 fc       	sbrc	r3, 2
    1422:	09 c0       	rjmp	.+18     	; 0x1436 <vfprintf+0x2d4>
    1424:	83 2d       	mov	r24, r3
    1426:	8e 7e       	andi	r24, 0xEE	; 238
    1428:	a8 2e       	mov	r10, r24
    142a:	05 c0       	rjmp	.+10     	; 0x1436 <vfprintf+0x2d4>
    142c:	b8 2c       	mov	r11, r8
    142e:	a3 2c       	mov	r10, r3
    1430:	03 c0       	rjmp	.+6      	; 0x1438 <vfprintf+0x2d6>
    1432:	b8 2c       	mov	r11, r8
    1434:	01 c0       	rjmp	.+2      	; 0x1438 <vfprintf+0x2d6>
    1436:	b9 2c       	mov	r11, r9
    1438:	a4 fe       	sbrs	r10, 4
    143a:	0f c0       	rjmp	.+30     	; 0x145a <vfprintf+0x2f8>
    143c:	fe 01       	movw	r30, r28
    143e:	e8 0d       	add	r30, r8
    1440:	f1 1d       	adc	r31, r1
    1442:	80 81       	ld	r24, Z
    1444:	80 33       	cpi	r24, 0x30	; 48
    1446:	21 f4       	brne	.+8      	; 0x1450 <vfprintf+0x2ee>
    1448:	9a 2d       	mov	r25, r10
    144a:	99 7e       	andi	r25, 0xE9	; 233
    144c:	a9 2e       	mov	r10, r25
    144e:	09 c0       	rjmp	.+18     	; 0x1462 <vfprintf+0x300>
    1450:	a2 fe       	sbrs	r10, 2
    1452:	06 c0       	rjmp	.+12     	; 0x1460 <vfprintf+0x2fe>
    1454:	b3 94       	inc	r11
    1456:	b3 94       	inc	r11
    1458:	04 c0       	rjmp	.+8      	; 0x1462 <vfprintf+0x300>
    145a:	8a 2d       	mov	r24, r10
    145c:	86 78       	andi	r24, 0x86	; 134
    145e:	09 f0       	breq	.+2      	; 0x1462 <vfprintf+0x300>
    1460:	b3 94       	inc	r11
    1462:	a3 fc       	sbrc	r10, 3
    1464:	11 c0       	rjmp	.+34     	; 0x1488 <vfprintf+0x326>
    1466:	a0 fe       	sbrs	r10, 0
    1468:	06 c0       	rjmp	.+12     	; 0x1476 <vfprintf+0x314>
    146a:	b2 14       	cp	r11, r2
    146c:	88 f4       	brcc	.+34     	; 0x1490 <vfprintf+0x32e>
    146e:	28 0c       	add	r2, r8
    1470:	92 2c       	mov	r9, r2
    1472:	9b 18       	sub	r9, r11
    1474:	0e c0       	rjmp	.+28     	; 0x1492 <vfprintf+0x330>
    1476:	b2 14       	cp	r11, r2
    1478:	60 f4       	brcc	.+24     	; 0x1492 <vfprintf+0x330>
    147a:	b6 01       	movw	r22, r12
    147c:	80 e2       	ldi	r24, 0x20	; 32
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	0e 94 a8 0a 	call	0x1550	; 0x1550 <fputc>
    1484:	b3 94       	inc	r11
    1486:	f7 cf       	rjmp	.-18     	; 0x1476 <vfprintf+0x314>
    1488:	b2 14       	cp	r11, r2
    148a:	18 f4       	brcc	.+6      	; 0x1492 <vfprintf+0x330>
    148c:	2b 18       	sub	r2, r11
    148e:	02 c0       	rjmp	.+4      	; 0x1494 <vfprintf+0x332>
    1490:	98 2c       	mov	r9, r8
    1492:	21 2c       	mov	r2, r1
    1494:	a4 fe       	sbrs	r10, 4
    1496:	10 c0       	rjmp	.+32     	; 0x14b8 <vfprintf+0x356>
    1498:	b6 01       	movw	r22, r12
    149a:	80 e3       	ldi	r24, 0x30	; 48
    149c:	90 e0       	ldi	r25, 0x00	; 0
    149e:	0e 94 a8 0a 	call	0x1550	; 0x1550 <fputc>
    14a2:	a2 fe       	sbrs	r10, 2
    14a4:	17 c0       	rjmp	.+46     	; 0x14d4 <vfprintf+0x372>
    14a6:	a1 fc       	sbrc	r10, 1
    14a8:	03 c0       	rjmp	.+6      	; 0x14b0 <vfprintf+0x34e>
    14aa:	88 e7       	ldi	r24, 0x78	; 120
    14ac:	90 e0       	ldi	r25, 0x00	; 0
    14ae:	02 c0       	rjmp	.+4      	; 0x14b4 <vfprintf+0x352>
    14b0:	88 e5       	ldi	r24, 0x58	; 88
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	b6 01       	movw	r22, r12
    14b6:	0c c0       	rjmp	.+24     	; 0x14d0 <vfprintf+0x36e>
    14b8:	8a 2d       	mov	r24, r10
    14ba:	86 78       	andi	r24, 0x86	; 134
    14bc:	59 f0       	breq	.+22     	; 0x14d4 <vfprintf+0x372>
    14be:	a1 fe       	sbrs	r10, 1
    14c0:	02 c0       	rjmp	.+4      	; 0x14c6 <vfprintf+0x364>
    14c2:	8b e2       	ldi	r24, 0x2B	; 43
    14c4:	01 c0       	rjmp	.+2      	; 0x14c8 <vfprintf+0x366>
    14c6:	80 e2       	ldi	r24, 0x20	; 32
    14c8:	a7 fc       	sbrc	r10, 7
    14ca:	8d e2       	ldi	r24, 0x2D	; 45
    14cc:	b6 01       	movw	r22, r12
    14ce:	90 e0       	ldi	r25, 0x00	; 0
    14d0:	0e 94 a8 0a 	call	0x1550	; 0x1550 <fputc>
    14d4:	89 14       	cp	r8, r9
    14d6:	38 f4       	brcc	.+14     	; 0x14e6 <vfprintf+0x384>
    14d8:	b6 01       	movw	r22, r12
    14da:	80 e3       	ldi	r24, 0x30	; 48
    14dc:	90 e0       	ldi	r25, 0x00	; 0
    14de:	0e 94 a8 0a 	call	0x1550	; 0x1550 <fputc>
    14e2:	9a 94       	dec	r9
    14e4:	f7 cf       	rjmp	.-18     	; 0x14d4 <vfprintf+0x372>
    14e6:	8a 94       	dec	r8
    14e8:	f3 01       	movw	r30, r6
    14ea:	e8 0d       	add	r30, r8
    14ec:	f1 1d       	adc	r31, r1
    14ee:	80 81       	ld	r24, Z
    14f0:	b6 01       	movw	r22, r12
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	0e 94 a8 0a 	call	0x1550	; 0x1550 <fputc>
    14f8:	81 10       	cpse	r8, r1
    14fa:	f5 cf       	rjmp	.-22     	; 0x14e6 <vfprintf+0x384>
    14fc:	22 20       	and	r2, r2
    14fe:	09 f4       	brne	.+2      	; 0x1502 <vfprintf+0x3a0>
    1500:	42 ce       	rjmp	.-892    	; 0x1186 <vfprintf+0x24>
    1502:	b6 01       	movw	r22, r12
    1504:	80 e2       	ldi	r24, 0x20	; 32
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	0e 94 a8 0a 	call	0x1550	; 0x1550 <fputc>
    150c:	2a 94       	dec	r2
    150e:	f6 cf       	rjmp	.-20     	; 0x14fc <vfprintf+0x39a>
    1510:	f6 01       	movw	r30, r12
    1512:	86 81       	ldd	r24, Z+6	; 0x06
    1514:	97 81       	ldd	r25, Z+7	; 0x07
    1516:	02 c0       	rjmp	.+4      	; 0x151c <vfprintf+0x3ba>
    1518:	8f ef       	ldi	r24, 0xFF	; 255
    151a:	9f ef       	ldi	r25, 0xFF	; 255
    151c:	2b 96       	adiw	r28, 0x0b	; 11
    151e:	e2 e1       	ldi	r30, 0x12	; 18
    1520:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__epilogue_restores__>

00001524 <strnlen_P>:
    1524:	fc 01       	movw	r30, r24
    1526:	05 90       	lpm	r0, Z+
    1528:	61 50       	subi	r22, 0x01	; 1
    152a:	70 40       	sbci	r23, 0x00	; 0
    152c:	01 10       	cpse	r0, r1
    152e:	d8 f7       	brcc	.-10     	; 0x1526 <strnlen_P+0x2>
    1530:	80 95       	com	r24
    1532:	90 95       	com	r25
    1534:	8e 0f       	add	r24, r30
    1536:	9f 1f       	adc	r25, r31
    1538:	08 95       	ret

0000153a <strnlen>:
    153a:	fc 01       	movw	r30, r24
    153c:	61 50       	subi	r22, 0x01	; 1
    153e:	70 40       	sbci	r23, 0x00	; 0
    1540:	01 90       	ld	r0, Z+
    1542:	01 10       	cpse	r0, r1
    1544:	d8 f7       	brcc	.-10     	; 0x153c <strnlen+0x2>
    1546:	80 95       	com	r24
    1548:	90 95       	com	r25
    154a:	8e 0f       	add	r24, r30
    154c:	9f 1f       	adc	r25, r31
    154e:	08 95       	ret

00001550 <fputc>:
    1550:	0f 93       	push	r16
    1552:	1f 93       	push	r17
    1554:	cf 93       	push	r28
    1556:	df 93       	push	r29
    1558:	fb 01       	movw	r30, r22
    155a:	23 81       	ldd	r18, Z+3	; 0x03
    155c:	21 fd       	sbrc	r18, 1
    155e:	03 c0       	rjmp	.+6      	; 0x1566 <fputc+0x16>
    1560:	8f ef       	ldi	r24, 0xFF	; 255
    1562:	9f ef       	ldi	r25, 0xFF	; 255
    1564:	2c c0       	rjmp	.+88     	; 0x15be <fputc+0x6e>
    1566:	22 ff       	sbrs	r18, 2
    1568:	16 c0       	rjmp	.+44     	; 0x1596 <fputc+0x46>
    156a:	46 81       	ldd	r20, Z+6	; 0x06
    156c:	57 81       	ldd	r21, Z+7	; 0x07
    156e:	24 81       	ldd	r18, Z+4	; 0x04
    1570:	35 81       	ldd	r19, Z+5	; 0x05
    1572:	42 17       	cp	r20, r18
    1574:	53 07       	cpc	r21, r19
    1576:	44 f4       	brge	.+16     	; 0x1588 <fputc+0x38>
    1578:	a0 81       	ld	r26, Z
    157a:	b1 81       	ldd	r27, Z+1	; 0x01
    157c:	9d 01       	movw	r18, r26
    157e:	2f 5f       	subi	r18, 0xFF	; 255
    1580:	3f 4f       	sbci	r19, 0xFF	; 255
    1582:	31 83       	std	Z+1, r19	; 0x01
    1584:	20 83       	st	Z, r18
    1586:	8c 93       	st	X, r24
    1588:	26 81       	ldd	r18, Z+6	; 0x06
    158a:	37 81       	ldd	r19, Z+7	; 0x07
    158c:	2f 5f       	subi	r18, 0xFF	; 255
    158e:	3f 4f       	sbci	r19, 0xFF	; 255
    1590:	37 83       	std	Z+7, r19	; 0x07
    1592:	26 83       	std	Z+6, r18	; 0x06
    1594:	14 c0       	rjmp	.+40     	; 0x15be <fputc+0x6e>
    1596:	8b 01       	movw	r16, r22
    1598:	ec 01       	movw	r28, r24
    159a:	fb 01       	movw	r30, r22
    159c:	00 84       	ldd	r0, Z+8	; 0x08
    159e:	f1 85       	ldd	r31, Z+9	; 0x09
    15a0:	e0 2d       	mov	r30, r0
    15a2:	09 95       	icall
    15a4:	89 2b       	or	r24, r25
    15a6:	e1 f6       	brne	.-72     	; 0x1560 <fputc+0x10>
    15a8:	d8 01       	movw	r26, r16
    15aa:	16 96       	adiw	r26, 0x06	; 6
    15ac:	8d 91       	ld	r24, X+
    15ae:	9c 91       	ld	r25, X
    15b0:	17 97       	sbiw	r26, 0x07	; 7
    15b2:	01 96       	adiw	r24, 0x01	; 1
    15b4:	17 96       	adiw	r26, 0x07	; 7
    15b6:	9c 93       	st	X, r25
    15b8:	8e 93       	st	-X, r24
    15ba:	16 97       	sbiw	r26, 0x06	; 6
    15bc:	ce 01       	movw	r24, r28
    15be:	df 91       	pop	r29
    15c0:	cf 91       	pop	r28
    15c2:	1f 91       	pop	r17
    15c4:	0f 91       	pop	r16
    15c6:	08 95       	ret

000015c8 <__ultoa_invert>:
    15c8:	fa 01       	movw	r30, r20
    15ca:	aa 27       	eor	r26, r26
    15cc:	28 30       	cpi	r18, 0x08	; 8
    15ce:	51 f1       	breq	.+84     	; 0x1624 <__ultoa_invert+0x5c>
    15d0:	20 31       	cpi	r18, 0x10	; 16
    15d2:	81 f1       	breq	.+96     	; 0x1634 <__ultoa_invert+0x6c>
    15d4:	e8 94       	clt
    15d6:	6f 93       	push	r22
    15d8:	6e 7f       	andi	r22, 0xFE	; 254
    15da:	6e 5f       	subi	r22, 0xFE	; 254
    15dc:	7f 4f       	sbci	r23, 0xFF	; 255
    15de:	8f 4f       	sbci	r24, 0xFF	; 255
    15e0:	9f 4f       	sbci	r25, 0xFF	; 255
    15e2:	af 4f       	sbci	r26, 0xFF	; 255
    15e4:	b1 e0       	ldi	r27, 0x01	; 1
    15e6:	3e d0       	rcall	.+124    	; 0x1664 <__ultoa_invert+0x9c>
    15e8:	b4 e0       	ldi	r27, 0x04	; 4
    15ea:	3c d0       	rcall	.+120    	; 0x1664 <__ultoa_invert+0x9c>
    15ec:	67 0f       	add	r22, r23
    15ee:	78 1f       	adc	r23, r24
    15f0:	89 1f       	adc	r24, r25
    15f2:	9a 1f       	adc	r25, r26
    15f4:	a1 1d       	adc	r26, r1
    15f6:	68 0f       	add	r22, r24
    15f8:	79 1f       	adc	r23, r25
    15fa:	8a 1f       	adc	r24, r26
    15fc:	91 1d       	adc	r25, r1
    15fe:	a1 1d       	adc	r26, r1
    1600:	6a 0f       	add	r22, r26
    1602:	71 1d       	adc	r23, r1
    1604:	81 1d       	adc	r24, r1
    1606:	91 1d       	adc	r25, r1
    1608:	a1 1d       	adc	r26, r1
    160a:	20 d0       	rcall	.+64     	; 0x164c <__ultoa_invert+0x84>
    160c:	09 f4       	brne	.+2      	; 0x1610 <__ultoa_invert+0x48>
    160e:	68 94       	set
    1610:	3f 91       	pop	r19
    1612:	2a e0       	ldi	r18, 0x0A	; 10
    1614:	26 9f       	mul	r18, r22
    1616:	11 24       	eor	r1, r1
    1618:	30 19       	sub	r19, r0
    161a:	30 5d       	subi	r19, 0xD0	; 208
    161c:	31 93       	st	Z+, r19
    161e:	de f6       	brtc	.-74     	; 0x15d6 <__ultoa_invert+0xe>
    1620:	cf 01       	movw	r24, r30
    1622:	08 95       	ret
    1624:	46 2f       	mov	r20, r22
    1626:	47 70       	andi	r20, 0x07	; 7
    1628:	40 5d       	subi	r20, 0xD0	; 208
    162a:	41 93       	st	Z+, r20
    162c:	b3 e0       	ldi	r27, 0x03	; 3
    162e:	0f d0       	rcall	.+30     	; 0x164e <__ultoa_invert+0x86>
    1630:	c9 f7       	brne	.-14     	; 0x1624 <__ultoa_invert+0x5c>
    1632:	f6 cf       	rjmp	.-20     	; 0x1620 <__ultoa_invert+0x58>
    1634:	46 2f       	mov	r20, r22
    1636:	4f 70       	andi	r20, 0x0F	; 15
    1638:	40 5d       	subi	r20, 0xD0	; 208
    163a:	4a 33       	cpi	r20, 0x3A	; 58
    163c:	18 f0       	brcs	.+6      	; 0x1644 <__ultoa_invert+0x7c>
    163e:	49 5d       	subi	r20, 0xD9	; 217
    1640:	31 fd       	sbrc	r19, 1
    1642:	40 52       	subi	r20, 0x20	; 32
    1644:	41 93       	st	Z+, r20
    1646:	02 d0       	rcall	.+4      	; 0x164c <__ultoa_invert+0x84>
    1648:	a9 f7       	brne	.-22     	; 0x1634 <__ultoa_invert+0x6c>
    164a:	ea cf       	rjmp	.-44     	; 0x1620 <__ultoa_invert+0x58>
    164c:	b4 e0       	ldi	r27, 0x04	; 4
    164e:	a6 95       	lsr	r26
    1650:	97 95       	ror	r25
    1652:	87 95       	ror	r24
    1654:	77 95       	ror	r23
    1656:	67 95       	ror	r22
    1658:	ba 95       	dec	r27
    165a:	c9 f7       	brne	.-14     	; 0x164e <__ultoa_invert+0x86>
    165c:	00 97       	sbiw	r24, 0x00	; 0
    165e:	61 05       	cpc	r22, r1
    1660:	71 05       	cpc	r23, r1
    1662:	08 95       	ret
    1664:	9b 01       	movw	r18, r22
    1666:	ac 01       	movw	r20, r24
    1668:	0a 2e       	mov	r0, r26
    166a:	06 94       	lsr	r0
    166c:	57 95       	ror	r21
    166e:	47 95       	ror	r20
    1670:	37 95       	ror	r19
    1672:	27 95       	ror	r18
    1674:	ba 95       	dec	r27
    1676:	c9 f7       	brne	.-14     	; 0x166a <__ultoa_invert+0xa2>
    1678:	62 0f       	add	r22, r18
    167a:	73 1f       	adc	r23, r19
    167c:	84 1f       	adc	r24, r20
    167e:	95 1f       	adc	r25, r21
    1680:	a0 1d       	adc	r26, r0
    1682:	08 95       	ret

00001684 <eeprom_read_byte>:
    1684:	f9 99       	sbic	0x1f, 1	; 31
    1686:	fe cf       	rjmp	.-4      	; 0x1684 <eeprom_read_byte>
    1688:	92 bd       	out	0x22, r25	; 34
    168a:	81 bd       	out	0x21, r24	; 33
    168c:	f8 9a       	sbi	0x1f, 0	; 31
    168e:	99 27       	eor	r25, r25
    1690:	80 b5       	in	r24, 0x20	; 32
    1692:	08 95       	ret

00001694 <eeprom_write_byte>:
    1694:	26 2f       	mov	r18, r22

00001696 <eeprom_write_r18>:
    1696:	f9 99       	sbic	0x1f, 1	; 31
    1698:	fe cf       	rjmp	.-4      	; 0x1696 <eeprom_write_r18>
    169a:	1f ba       	out	0x1f, r1	; 31
    169c:	92 bd       	out	0x22, r25	; 34
    169e:	81 bd       	out	0x21, r24	; 33
    16a0:	20 bd       	out	0x20, r18	; 32
    16a2:	0f b6       	in	r0, 0x3f	; 63
    16a4:	f8 94       	cli
    16a6:	fa 9a       	sbi	0x1f, 2	; 31
    16a8:	f9 9a       	sbi	0x1f, 1	; 31
    16aa:	0f be       	out	0x3f, r0	; 63
    16ac:	01 96       	adiw	r24, 0x01	; 1
    16ae:	08 95       	ret

000016b0 <__divmodsi4>:
    16b0:	05 2e       	mov	r0, r21
    16b2:	97 fb       	bst	r25, 7
    16b4:	1e f4       	brtc	.+6      	; 0x16bc <__divmodsi4+0xc>
    16b6:	00 94       	com	r0
    16b8:	0e 94 6f 0b 	call	0x16de	; 0x16de <__negsi2>
    16bc:	57 fd       	sbrc	r21, 7
    16be:	07 d0       	rcall	.+14     	; 0x16ce <__divmodsi4_neg2>
    16c0:	0e 94 c1 0b 	call	0x1782	; 0x1782 <__udivmodsi4>
    16c4:	07 fc       	sbrc	r0, 7
    16c6:	03 d0       	rcall	.+6      	; 0x16ce <__divmodsi4_neg2>
    16c8:	4e f4       	brtc	.+18     	; 0x16dc <__divmodsi4_exit>
    16ca:	0c 94 6f 0b 	jmp	0x16de	; 0x16de <__negsi2>

000016ce <__divmodsi4_neg2>:
    16ce:	50 95       	com	r21
    16d0:	40 95       	com	r20
    16d2:	30 95       	com	r19
    16d4:	21 95       	neg	r18
    16d6:	3f 4f       	sbci	r19, 0xFF	; 255
    16d8:	4f 4f       	sbci	r20, 0xFF	; 255
    16da:	5f 4f       	sbci	r21, 0xFF	; 255

000016dc <__divmodsi4_exit>:
    16dc:	08 95       	ret

000016de <__negsi2>:
    16de:	90 95       	com	r25
    16e0:	80 95       	com	r24
    16e2:	70 95       	com	r23
    16e4:	61 95       	neg	r22
    16e6:	7f 4f       	sbci	r23, 0xFF	; 255
    16e8:	8f 4f       	sbci	r24, 0xFF	; 255
    16ea:	9f 4f       	sbci	r25, 0xFF	; 255
    16ec:	08 95       	ret

000016ee <__muluhisi3>:
    16ee:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__umulhisi3>
    16f2:	a5 9f       	mul	r26, r21
    16f4:	90 0d       	add	r25, r0
    16f6:	b4 9f       	mul	r27, r20
    16f8:	90 0d       	add	r25, r0
    16fa:	a4 9f       	mul	r26, r20
    16fc:	80 0d       	add	r24, r0
    16fe:	91 1d       	adc	r25, r1
    1700:	11 24       	eor	r1, r1
    1702:	08 95       	ret

00001704 <__mulshisi3>:
    1704:	b7 ff       	sbrs	r27, 7
    1706:	0c 94 77 0b 	jmp	0x16ee	; 0x16ee <__muluhisi3>

0000170a <__mulohisi3>:
    170a:	0e 94 77 0b 	call	0x16ee	; 0x16ee <__muluhisi3>
    170e:	82 1b       	sub	r24, r18
    1710:	93 0b       	sbc	r25, r19
    1712:	08 95       	ret

00001714 <__prologue_saves__>:
    1714:	2f 92       	push	r2
    1716:	3f 92       	push	r3
    1718:	4f 92       	push	r4
    171a:	5f 92       	push	r5
    171c:	6f 92       	push	r6
    171e:	7f 92       	push	r7
    1720:	8f 92       	push	r8
    1722:	9f 92       	push	r9
    1724:	af 92       	push	r10
    1726:	bf 92       	push	r11
    1728:	cf 92       	push	r12
    172a:	df 92       	push	r13
    172c:	ef 92       	push	r14
    172e:	ff 92       	push	r15
    1730:	0f 93       	push	r16
    1732:	1f 93       	push	r17
    1734:	cf 93       	push	r28
    1736:	df 93       	push	r29
    1738:	cd b7       	in	r28, 0x3d	; 61
    173a:	de b7       	in	r29, 0x3e	; 62
    173c:	ca 1b       	sub	r28, r26
    173e:	db 0b       	sbc	r29, r27
    1740:	0f b6       	in	r0, 0x3f	; 63
    1742:	f8 94       	cli
    1744:	de bf       	out	0x3e, r29	; 62
    1746:	0f be       	out	0x3f, r0	; 63
    1748:	cd bf       	out	0x3d, r28	; 61
    174a:	09 94       	ijmp

0000174c <__epilogue_restores__>:
    174c:	2a 88       	ldd	r2, Y+18	; 0x12
    174e:	39 88       	ldd	r3, Y+17	; 0x11
    1750:	48 88       	ldd	r4, Y+16	; 0x10
    1752:	5f 84       	ldd	r5, Y+15	; 0x0f
    1754:	6e 84       	ldd	r6, Y+14	; 0x0e
    1756:	7d 84       	ldd	r7, Y+13	; 0x0d
    1758:	8c 84       	ldd	r8, Y+12	; 0x0c
    175a:	9b 84       	ldd	r9, Y+11	; 0x0b
    175c:	aa 84       	ldd	r10, Y+10	; 0x0a
    175e:	b9 84       	ldd	r11, Y+9	; 0x09
    1760:	c8 84       	ldd	r12, Y+8	; 0x08
    1762:	df 80       	ldd	r13, Y+7	; 0x07
    1764:	ee 80       	ldd	r14, Y+6	; 0x06
    1766:	fd 80       	ldd	r15, Y+5	; 0x05
    1768:	0c 81       	ldd	r16, Y+4	; 0x04
    176a:	1b 81       	ldd	r17, Y+3	; 0x03
    176c:	aa 81       	ldd	r26, Y+2	; 0x02
    176e:	b9 81       	ldd	r27, Y+1	; 0x01
    1770:	ce 0f       	add	r28, r30
    1772:	d1 1d       	adc	r29, r1
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	de bf       	out	0x3e, r29	; 62
    177a:	0f be       	out	0x3f, r0	; 63
    177c:	cd bf       	out	0x3d, r28	; 61
    177e:	ed 01       	movw	r28, r26
    1780:	08 95       	ret

00001782 <__udivmodsi4>:
    1782:	a1 e2       	ldi	r26, 0x21	; 33
    1784:	1a 2e       	mov	r1, r26
    1786:	aa 1b       	sub	r26, r26
    1788:	bb 1b       	sub	r27, r27
    178a:	fd 01       	movw	r30, r26
    178c:	0d c0       	rjmp	.+26     	; 0x17a8 <__udivmodsi4_ep>

0000178e <__udivmodsi4_loop>:
    178e:	aa 1f       	adc	r26, r26
    1790:	bb 1f       	adc	r27, r27
    1792:	ee 1f       	adc	r30, r30
    1794:	ff 1f       	adc	r31, r31
    1796:	a2 17       	cp	r26, r18
    1798:	b3 07       	cpc	r27, r19
    179a:	e4 07       	cpc	r30, r20
    179c:	f5 07       	cpc	r31, r21
    179e:	20 f0       	brcs	.+8      	; 0x17a8 <__udivmodsi4_ep>
    17a0:	a2 1b       	sub	r26, r18
    17a2:	b3 0b       	sbc	r27, r19
    17a4:	e4 0b       	sbc	r30, r20
    17a6:	f5 0b       	sbc	r31, r21

000017a8 <__udivmodsi4_ep>:
    17a8:	66 1f       	adc	r22, r22
    17aa:	77 1f       	adc	r23, r23
    17ac:	88 1f       	adc	r24, r24
    17ae:	99 1f       	adc	r25, r25
    17b0:	1a 94       	dec	r1
    17b2:	69 f7       	brne	.-38     	; 0x178e <__udivmodsi4_loop>
    17b4:	60 95       	com	r22
    17b6:	70 95       	com	r23
    17b8:	80 95       	com	r24
    17ba:	90 95       	com	r25
    17bc:	9b 01       	movw	r18, r22
    17be:	ac 01       	movw	r20, r24
    17c0:	bd 01       	movw	r22, r26
    17c2:	cf 01       	movw	r24, r30
    17c4:	08 95       	ret

000017c6 <__umulhisi3>:
    17c6:	a2 9f       	mul	r26, r18
    17c8:	b0 01       	movw	r22, r0
    17ca:	b3 9f       	mul	r27, r19
    17cc:	c0 01       	movw	r24, r0
    17ce:	a3 9f       	mul	r26, r19
    17d0:	70 0d       	add	r23, r0
    17d2:	81 1d       	adc	r24, r1
    17d4:	11 24       	eor	r1, r1
    17d6:	91 1d       	adc	r25, r1
    17d8:	b2 9f       	mul	r27, r18
    17da:	70 0d       	add	r23, r0
    17dc:	81 1d       	adc	r24, r1
    17de:	11 24       	eor	r1, r1
    17e0:	91 1d       	adc	r25, r1
    17e2:	08 95       	ret

000017e4 <_exit>:
    17e4:	f8 94       	cli

000017e6 <__stop_program>:
    17e6:	ff cf       	rjmp	.-2      	; 0x17e6 <__stop_program>
